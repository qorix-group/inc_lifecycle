/********************************************************************************
 * Copyright (c) 2025 Contributors to the Eclipse Foundation
 *
 * See the NOTICE file(s) distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Apache License Version 2.0 which is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * SPDX-License-Identifier: Apache-2.0
 ********************************************************************************/
// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_HMFLATCFG_HMFLATBUFFER_H_
#define FLATBUFFERS_GENERATED_HMFLATCFG_HMFLATBUFFER_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 25 &&
              FLATBUFFERS_VERSION_MINOR == 9 &&
              FLATBUFFERS_VERSION_REVISION == 23,
             "Non-compatible flatbuffers version included");

namespace HMFlatBuffer {

struct HMEcuCfg;
struct HMEcuCfgBuilder;

struct Process;
struct ProcessBuilder;

struct HmProcessExecutionError;
struct HmProcessExecutionErrorBuilder;

struct HmRefProcessGroupStates;
struct HmRefProcessGroupStatesBuilder;

struct HmRefProcess;
struct HmRefProcessBuilder;

struct HmMonitorInterface;
struct HmMonitorInterfaceBuilder;

struct HmSupervisionCheckpoint;
struct HmSupervisionCheckpointBuilder;

struct HmCheckpointTransition;
struct HmCheckpointTransitionBuilder;

struct HmAliveSupervision;
struct HmAliveSupervisionBuilder;

struct HmDeadlineSupervision;
struct HmDeadlineSupervisionBuilder;

struct HmLogicalSupervision;
struct HmLogicalSupervisionBuilder;

struct HmLogicalCheckpoint;
struct HmLogicalCheckpointBuilder;

struct HmLogicalTransition;
struct HmLogicalTransitionBuilder;

struct HmLocalSupervision;
struct HmLocalSupervisionBuilder;

struct HmRefAliveSupervision;
struct HmRefAliveSupervisionBuilder;

struct HmRefDeadlineSupervision;
struct HmRefDeadlineSupervisionBuilder;

struct HmRefLogicalSupervision;
struct HmRefLogicalSupervisionBuilder;

struct HmGlobalSupervision;
struct HmGlobalSupervisionBuilder;

struct HmGlobalSupervisionLocalRef;
struct HmGlobalSupervisionLocalRefBuilder;

struct HmRefProcessGroupStatesGlobal;
struct HmRefProcessGroupStatesGlobalBuilder;

struct RecoveryNotification;
struct RecoveryNotificationBuilder;

enum ProcessType : int8_t {
  ProcessType_REGULAR_PROCESS = 0,
  ProcessType_LM_PROCESS = 1,
  ProcessType_STM_PROCESS = 2,
  ProcessType_MIN = ProcessType_REGULAR_PROCESS,
  ProcessType_MAX = ProcessType_STM_PROCESS
};

inline const ProcessType (&EnumValuesProcessType())[3] {
  static const ProcessType values[] = {
    ProcessType_REGULAR_PROCESS,
    ProcessType_LM_PROCESS,
    ProcessType_STM_PROCESS
  };
  return values;
}

inline const char * const *EnumNamesProcessType() {
  static const char * const names[4] = {
    "REGULAR_PROCESS",
    "LM_PROCESS",
    "STM_PROCESS",
    nullptr
  };
  return names;
}

inline const char *EnumNameProcessType(ProcessType e) {
  if (::flatbuffers::IsOutRange(e, ProcessType_REGULAR_PROCESS, ProcessType_STM_PROCESS)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesProcessType()[index];
}

struct HMEcuCfg FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef HMEcuCfgBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VERSIONMAJOR = 4,
    VT_VERSIONMINOR = 6,
    VT_PROCESS = 8,
    VT_HMMONITORINTERFACE = 10,
    VT_HMSUPERVISIONCHECKPOINT = 12,
    VT_HMALIVESUPERVISION = 14,
    VT_HMDEADLINESUPERVISION = 16,
    VT_HMLOGICALSUPERVISION = 18,
    VT_HMLOCALSUPERVISION = 20,
    VT_HMGLOBALSUPERVISION = 22,
    VT_HMRECOVERYNOTIFICATION = 24
  };
  int32_t versionMajor() const {
    return GetField<int32_t>(VT_VERSIONMAJOR, 0);
  }
  int32_t versionMinor() const {
    return GetField<int32_t>(VT_VERSIONMINOR, 0);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<HMFlatBuffer::Process>> *process() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<HMFlatBuffer::Process>> *>(VT_PROCESS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<HMFlatBuffer::HmMonitorInterface>> *hmMonitorInterface() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<HMFlatBuffer::HmMonitorInterface>> *>(VT_HMMONITORINTERFACE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<HMFlatBuffer::HmSupervisionCheckpoint>> *hmSupervisionCheckpoint() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<HMFlatBuffer::HmSupervisionCheckpoint>> *>(VT_HMSUPERVISIONCHECKPOINT);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<HMFlatBuffer::HmAliveSupervision>> *hmAliveSupervision() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<HMFlatBuffer::HmAliveSupervision>> *>(VT_HMALIVESUPERVISION);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<HMFlatBuffer::HmDeadlineSupervision>> *hmDeadlineSupervision() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<HMFlatBuffer::HmDeadlineSupervision>> *>(VT_HMDEADLINESUPERVISION);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<HMFlatBuffer::HmLogicalSupervision>> *hmLogicalSupervision() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<HMFlatBuffer::HmLogicalSupervision>> *>(VT_HMLOGICALSUPERVISION);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<HMFlatBuffer::HmLocalSupervision>> *hmLocalSupervision() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<HMFlatBuffer::HmLocalSupervision>> *>(VT_HMLOCALSUPERVISION);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<HMFlatBuffer::HmGlobalSupervision>> *hmGlobalSupervision() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<HMFlatBuffer::HmGlobalSupervision>> *>(VT_HMGLOBALSUPERVISION);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<HMFlatBuffer::RecoveryNotification>> *hmRecoveryNotification() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<HMFlatBuffer::RecoveryNotification>> *>(VT_HMRECOVERYNOTIFICATION);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_VERSIONMAJOR, 4) &&
           VerifyField<int32_t>(verifier, VT_VERSIONMINOR, 4) &&
           VerifyOffset(verifier, VT_PROCESS) &&
           verifier.VerifyVector(process()) &&
           verifier.VerifyVectorOfTables(process()) &&
           VerifyOffset(verifier, VT_HMMONITORINTERFACE) &&
           verifier.VerifyVector(hmMonitorInterface()) &&
           verifier.VerifyVectorOfTables(hmMonitorInterface()) &&
           VerifyOffset(verifier, VT_HMSUPERVISIONCHECKPOINT) &&
           verifier.VerifyVector(hmSupervisionCheckpoint()) &&
           verifier.VerifyVectorOfTables(hmSupervisionCheckpoint()) &&
           VerifyOffset(verifier, VT_HMALIVESUPERVISION) &&
           verifier.VerifyVector(hmAliveSupervision()) &&
           verifier.VerifyVectorOfTables(hmAliveSupervision()) &&
           VerifyOffset(verifier, VT_HMDEADLINESUPERVISION) &&
           verifier.VerifyVector(hmDeadlineSupervision()) &&
           verifier.VerifyVectorOfTables(hmDeadlineSupervision()) &&
           VerifyOffset(verifier, VT_HMLOGICALSUPERVISION) &&
           verifier.VerifyVector(hmLogicalSupervision()) &&
           verifier.VerifyVectorOfTables(hmLogicalSupervision()) &&
           VerifyOffset(verifier, VT_HMLOCALSUPERVISION) &&
           verifier.VerifyVector(hmLocalSupervision()) &&
           verifier.VerifyVectorOfTables(hmLocalSupervision()) &&
           VerifyOffset(verifier, VT_HMGLOBALSUPERVISION) &&
           verifier.VerifyVector(hmGlobalSupervision()) &&
           verifier.VerifyVectorOfTables(hmGlobalSupervision()) &&
           VerifyOffset(verifier, VT_HMRECOVERYNOTIFICATION) &&
           verifier.VerifyVector(hmRecoveryNotification()) &&
           verifier.VerifyVectorOfTables(hmRecoveryNotification()) &&
           verifier.EndTable();
  }
};

struct HMEcuCfgBuilder {
  typedef HMEcuCfg Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_versionMajor(int32_t versionMajor) {
    fbb_.AddElement<int32_t>(HMEcuCfg::VT_VERSIONMAJOR, versionMajor, 0);
  }
  void add_versionMinor(int32_t versionMinor) {
    fbb_.AddElement<int32_t>(HMEcuCfg::VT_VERSIONMINOR, versionMinor, 0);
  }
  void add_process(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<HMFlatBuffer::Process>>> process) {
    fbb_.AddOffset(HMEcuCfg::VT_PROCESS, process);
  }
  void add_hmMonitorInterface(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<HMFlatBuffer::HmMonitorInterface>>> hmMonitorInterface) {
    fbb_.AddOffset(HMEcuCfg::VT_HMMONITORINTERFACE, hmMonitorInterface);
  }
  void add_hmSupervisionCheckpoint(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<HMFlatBuffer::HmSupervisionCheckpoint>>> hmSupervisionCheckpoint) {
    fbb_.AddOffset(HMEcuCfg::VT_HMSUPERVISIONCHECKPOINT, hmSupervisionCheckpoint);
  }
  void add_hmAliveSupervision(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<HMFlatBuffer::HmAliveSupervision>>> hmAliveSupervision) {
    fbb_.AddOffset(HMEcuCfg::VT_HMALIVESUPERVISION, hmAliveSupervision);
  }
  void add_hmDeadlineSupervision(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<HMFlatBuffer::HmDeadlineSupervision>>> hmDeadlineSupervision) {
    fbb_.AddOffset(HMEcuCfg::VT_HMDEADLINESUPERVISION, hmDeadlineSupervision);
  }
  void add_hmLogicalSupervision(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<HMFlatBuffer::HmLogicalSupervision>>> hmLogicalSupervision) {
    fbb_.AddOffset(HMEcuCfg::VT_HMLOGICALSUPERVISION, hmLogicalSupervision);
  }
  void add_hmLocalSupervision(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<HMFlatBuffer::HmLocalSupervision>>> hmLocalSupervision) {
    fbb_.AddOffset(HMEcuCfg::VT_HMLOCALSUPERVISION, hmLocalSupervision);
  }
  void add_hmGlobalSupervision(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<HMFlatBuffer::HmGlobalSupervision>>> hmGlobalSupervision) {
    fbb_.AddOffset(HMEcuCfg::VT_HMGLOBALSUPERVISION, hmGlobalSupervision);
  }
  void add_hmRecoveryNotification(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<HMFlatBuffer::RecoveryNotification>>> hmRecoveryNotification) {
    fbb_.AddOffset(HMEcuCfg::VT_HMRECOVERYNOTIFICATION, hmRecoveryNotification);
  }
  explicit HMEcuCfgBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<HMEcuCfg> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<HMEcuCfg>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<HMEcuCfg> CreateHMEcuCfg(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t versionMajor = 0,
    int32_t versionMinor = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<HMFlatBuffer::Process>>> process = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<HMFlatBuffer::HmMonitorInterface>>> hmMonitorInterface = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<HMFlatBuffer::HmSupervisionCheckpoint>>> hmSupervisionCheckpoint = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<HMFlatBuffer::HmAliveSupervision>>> hmAliveSupervision = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<HMFlatBuffer::HmDeadlineSupervision>>> hmDeadlineSupervision = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<HMFlatBuffer::HmLogicalSupervision>>> hmLogicalSupervision = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<HMFlatBuffer::HmLocalSupervision>>> hmLocalSupervision = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<HMFlatBuffer::HmGlobalSupervision>>> hmGlobalSupervision = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<HMFlatBuffer::RecoveryNotification>>> hmRecoveryNotification = 0) {
  HMEcuCfgBuilder builder_(_fbb);
  builder_.add_hmRecoveryNotification(hmRecoveryNotification);
  builder_.add_hmGlobalSupervision(hmGlobalSupervision);
  builder_.add_hmLocalSupervision(hmLocalSupervision);
  builder_.add_hmLogicalSupervision(hmLogicalSupervision);
  builder_.add_hmDeadlineSupervision(hmDeadlineSupervision);
  builder_.add_hmAliveSupervision(hmAliveSupervision);
  builder_.add_hmSupervisionCheckpoint(hmSupervisionCheckpoint);
  builder_.add_hmMonitorInterface(hmMonitorInterface);
  builder_.add_process(process);
  builder_.add_versionMinor(versionMinor);
  builder_.add_versionMajor(versionMajor);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<HMEcuCfg> CreateHMEcuCfgDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t versionMajor = 0,
    int32_t versionMinor = 0,
    const std::vector<::flatbuffers::Offset<HMFlatBuffer::Process>> *process = nullptr,
    const std::vector<::flatbuffers::Offset<HMFlatBuffer::HmMonitorInterface>> *hmMonitorInterface = nullptr,
    const std::vector<::flatbuffers::Offset<HMFlatBuffer::HmSupervisionCheckpoint>> *hmSupervisionCheckpoint = nullptr,
    const std::vector<::flatbuffers::Offset<HMFlatBuffer::HmAliveSupervision>> *hmAliveSupervision = nullptr,
    const std::vector<::flatbuffers::Offset<HMFlatBuffer::HmDeadlineSupervision>> *hmDeadlineSupervision = nullptr,
    const std::vector<::flatbuffers::Offset<HMFlatBuffer::HmLogicalSupervision>> *hmLogicalSupervision = nullptr,
    const std::vector<::flatbuffers::Offset<HMFlatBuffer::HmLocalSupervision>> *hmLocalSupervision = nullptr,
    const std::vector<::flatbuffers::Offset<HMFlatBuffer::HmGlobalSupervision>> *hmGlobalSupervision = nullptr,
    const std::vector<::flatbuffers::Offset<HMFlatBuffer::RecoveryNotification>> *hmRecoveryNotification = nullptr) {
  auto process__ = process ? _fbb.CreateVector<::flatbuffers::Offset<HMFlatBuffer::Process>>(*process) : 0;
  auto hmMonitorInterface__ = hmMonitorInterface ? _fbb.CreateVector<::flatbuffers::Offset<HMFlatBuffer::HmMonitorInterface>>(*hmMonitorInterface) : 0;
  auto hmSupervisionCheckpoint__ = hmSupervisionCheckpoint ? _fbb.CreateVector<::flatbuffers::Offset<HMFlatBuffer::HmSupervisionCheckpoint>>(*hmSupervisionCheckpoint) : 0;
  auto hmAliveSupervision__ = hmAliveSupervision ? _fbb.CreateVector<::flatbuffers::Offset<HMFlatBuffer::HmAliveSupervision>>(*hmAliveSupervision) : 0;
  auto hmDeadlineSupervision__ = hmDeadlineSupervision ? _fbb.CreateVector<::flatbuffers::Offset<HMFlatBuffer::HmDeadlineSupervision>>(*hmDeadlineSupervision) : 0;
  auto hmLogicalSupervision__ = hmLogicalSupervision ? _fbb.CreateVector<::flatbuffers::Offset<HMFlatBuffer::HmLogicalSupervision>>(*hmLogicalSupervision) : 0;
  auto hmLocalSupervision__ = hmLocalSupervision ? _fbb.CreateVector<::flatbuffers::Offset<HMFlatBuffer::HmLocalSupervision>>(*hmLocalSupervision) : 0;
  auto hmGlobalSupervision__ = hmGlobalSupervision ? _fbb.CreateVector<::flatbuffers::Offset<HMFlatBuffer::HmGlobalSupervision>>(*hmGlobalSupervision) : 0;
  auto hmRecoveryNotification__ = hmRecoveryNotification ? _fbb.CreateVector<::flatbuffers::Offset<HMFlatBuffer::RecoveryNotification>>(*hmRecoveryNotification) : 0;
  return HMFlatBuffer::CreateHMEcuCfg(
      _fbb,
      versionMajor,
      versionMinor,
      process__,
      hmMonitorInterface__,
      hmSupervisionCheckpoint__,
      hmAliveSupervision__,
      hmDeadlineSupervision__,
      hmLogicalSupervision__,
      hmLocalSupervision__,
      hmGlobalSupervision__,
      hmRecoveryNotification__);
}

struct Process FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ProcessBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SHORTNAME = 4,
    VT_IDENTIFIER = 6,
    VT_INDEX = 8,
    VT_PROCESSTYPE = 10,
    VT_REFPROCESSGROUPSTATES = 12,
    VT_PROCESSEXECUTIONERRORS = 14
  };
  const ::flatbuffers::String *shortName() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SHORTNAME);
  }
  const ::flatbuffers::String *identifier() const {
    return GetPointer<const ::flatbuffers::String *>(VT_IDENTIFIER);
  }
  uint32_t index() const {
    return GetField<uint32_t>(VT_INDEX, 0);
  }
  HMFlatBuffer::ProcessType processType() const {
    return static_cast<HMFlatBuffer::ProcessType>(GetField<int8_t>(VT_PROCESSTYPE, 0));
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<HMFlatBuffer::HmRefProcessGroupStates>> *refProcessGroupStates() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<HMFlatBuffer::HmRefProcessGroupStates>> *>(VT_REFPROCESSGROUPSTATES);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<HMFlatBuffer::HmProcessExecutionError>> *processExecutionErrors() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<HMFlatBuffer::HmProcessExecutionError>> *>(VT_PROCESSEXECUTIONERRORS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SHORTNAME) &&
           verifier.VerifyString(shortName()) &&
           VerifyOffset(verifier, VT_IDENTIFIER) &&
           verifier.VerifyString(identifier()) &&
           VerifyField<uint32_t>(verifier, VT_INDEX, 4) &&
           VerifyField<int8_t>(verifier, VT_PROCESSTYPE, 1) &&
           VerifyOffset(verifier, VT_REFPROCESSGROUPSTATES) &&
           verifier.VerifyVector(refProcessGroupStates()) &&
           verifier.VerifyVectorOfTables(refProcessGroupStates()) &&
           VerifyOffset(verifier, VT_PROCESSEXECUTIONERRORS) &&
           verifier.VerifyVector(processExecutionErrors()) &&
           verifier.VerifyVectorOfTables(processExecutionErrors()) &&
           verifier.EndTable();
  }
};

struct ProcessBuilder {
  typedef Process Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_shortName(::flatbuffers::Offset<::flatbuffers::String> shortName) {
    fbb_.AddOffset(Process::VT_SHORTNAME, shortName);
  }
  void add_identifier(::flatbuffers::Offset<::flatbuffers::String> identifier) {
    fbb_.AddOffset(Process::VT_IDENTIFIER, identifier);
  }
  void add_index(uint32_t index) {
    fbb_.AddElement<uint32_t>(Process::VT_INDEX, index, 0);
  }
  void add_processType(HMFlatBuffer::ProcessType processType) {
    fbb_.AddElement<int8_t>(Process::VT_PROCESSTYPE, static_cast<int8_t>(processType), 0);
  }
  void add_refProcessGroupStates(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<HMFlatBuffer::HmRefProcessGroupStates>>> refProcessGroupStates) {
    fbb_.AddOffset(Process::VT_REFPROCESSGROUPSTATES, refProcessGroupStates);
  }
  void add_processExecutionErrors(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<HMFlatBuffer::HmProcessExecutionError>>> processExecutionErrors) {
    fbb_.AddOffset(Process::VT_PROCESSEXECUTIONERRORS, processExecutionErrors);
  }
  explicit ProcessBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Process> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Process>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Process> CreateProcess(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> shortName = 0,
    ::flatbuffers::Offset<::flatbuffers::String> identifier = 0,
    uint32_t index = 0,
    HMFlatBuffer::ProcessType processType = HMFlatBuffer::ProcessType_REGULAR_PROCESS,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<HMFlatBuffer::HmRefProcessGroupStates>>> refProcessGroupStates = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<HMFlatBuffer::HmProcessExecutionError>>> processExecutionErrors = 0) {
  ProcessBuilder builder_(_fbb);
  builder_.add_processExecutionErrors(processExecutionErrors);
  builder_.add_refProcessGroupStates(refProcessGroupStates);
  builder_.add_index(index);
  builder_.add_identifier(identifier);
  builder_.add_shortName(shortName);
  builder_.add_processType(processType);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Process> CreateProcessDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *shortName = nullptr,
    const char *identifier = nullptr,
    uint32_t index = 0,
    HMFlatBuffer::ProcessType processType = HMFlatBuffer::ProcessType_REGULAR_PROCESS,
    const std::vector<::flatbuffers::Offset<HMFlatBuffer::HmRefProcessGroupStates>> *refProcessGroupStates = nullptr,
    const std::vector<::flatbuffers::Offset<HMFlatBuffer::HmProcessExecutionError>> *processExecutionErrors = nullptr) {
  auto shortName__ = shortName ? _fbb.CreateString(shortName) : 0;
  auto identifier__ = identifier ? _fbb.CreateString(identifier) : 0;
  auto refProcessGroupStates__ = refProcessGroupStates ? _fbb.CreateVector<::flatbuffers::Offset<HMFlatBuffer::HmRefProcessGroupStates>>(*refProcessGroupStates) : 0;
  auto processExecutionErrors__ = processExecutionErrors ? _fbb.CreateVector<::flatbuffers::Offset<HMFlatBuffer::HmProcessExecutionError>>(*processExecutionErrors) : 0;
  return HMFlatBuffer::CreateProcess(
      _fbb,
      shortName__,
      identifier__,
      index,
      processType,
      refProcessGroupStates__,
      processExecutionErrors__);
}

struct HmProcessExecutionError FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef HmProcessExecutionErrorBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PROCESSEXECUTIONERROR = 4
  };
  uint32_t processExecutionError() const {
    return GetField<uint32_t>(VT_PROCESSEXECUTIONERROR, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_PROCESSEXECUTIONERROR, 4) &&
           verifier.EndTable();
  }
};

struct HmProcessExecutionErrorBuilder {
  typedef HmProcessExecutionError Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_processExecutionError(uint32_t processExecutionError) {
    fbb_.AddElement<uint32_t>(HmProcessExecutionError::VT_PROCESSEXECUTIONERROR, processExecutionError, 0);
  }
  explicit HmProcessExecutionErrorBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<HmProcessExecutionError> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<HmProcessExecutionError>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<HmProcessExecutionError> CreateHmProcessExecutionError(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t processExecutionError = 0) {
  HmProcessExecutionErrorBuilder builder_(_fbb);
  builder_.add_processExecutionError(processExecutionError);
  return builder_.Finish();
}

struct HmRefProcessGroupStates FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef HmRefProcessGroupStatesBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_IDENTIFIER = 4
  };
  const ::flatbuffers::String *identifier() const {
    return GetPointer<const ::flatbuffers::String *>(VT_IDENTIFIER);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_IDENTIFIER) &&
           verifier.VerifyString(identifier()) &&
           verifier.EndTable();
  }
};

struct HmRefProcessGroupStatesBuilder {
  typedef HmRefProcessGroupStates Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_identifier(::flatbuffers::Offset<::flatbuffers::String> identifier) {
    fbb_.AddOffset(HmRefProcessGroupStates::VT_IDENTIFIER, identifier);
  }
  explicit HmRefProcessGroupStatesBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<HmRefProcessGroupStates> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<HmRefProcessGroupStates>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<HmRefProcessGroupStates> CreateHmRefProcessGroupStates(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> identifier = 0) {
  HmRefProcessGroupStatesBuilder builder_(_fbb);
  builder_.add_identifier(identifier);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<HmRefProcessGroupStates> CreateHmRefProcessGroupStatesDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *identifier = nullptr) {
  auto identifier__ = identifier ? _fbb.CreateString(identifier) : 0;
  return HMFlatBuffer::CreateHmRefProcessGroupStates(
      _fbb,
      identifier__);
}

struct HmRefProcess FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef HmRefProcessBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INDEX = 4
  };
  uint32_t index() const {
    return GetField<uint32_t>(VT_INDEX, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_INDEX, 4) &&
           verifier.EndTable();
  }
};

struct HmRefProcessBuilder {
  typedef HmRefProcess Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_index(uint32_t index) {
    fbb_.AddElement<uint32_t>(HmRefProcess::VT_INDEX, index, 0);
  }
  explicit HmRefProcessBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<HmRefProcess> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<HmRefProcess>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<HmRefProcess> CreateHmRefProcess(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t index = 0) {
  HmRefProcessBuilder builder_(_fbb);
  builder_.add_index(index);
  return builder_.Finish();
}

struct HmMonitorInterface FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef HmMonitorInterfaceBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INSTANCESPECIFIER = 4,
    VT_PROCESSSHORTNAME = 6,
    VT_PORTPROTOTYPE = 8,
    VT_INTERFACEPATH = 10,
    VT_REFPROCESSINDEX = 12,
    VT_PERMITTEDUID = 14
  };
  const ::flatbuffers::String *instanceSpecifier() const {
    return GetPointer<const ::flatbuffers::String *>(VT_INSTANCESPECIFIER);
  }
  const ::flatbuffers::String *processShortName() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PROCESSSHORTNAME);
  }
  const ::flatbuffers::String *portPrototype() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PORTPROTOTYPE);
  }
  const ::flatbuffers::String *interfacePath() const {
    return GetPointer<const ::flatbuffers::String *>(VT_INTERFACEPATH);
  }
  uint32_t refProcessIndex() const {
    return GetField<uint32_t>(VT_REFPROCESSINDEX, 0);
  }
  int32_t permittedUid() const {
    return GetField<int32_t>(VT_PERMITTEDUID, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_INSTANCESPECIFIER) &&
           verifier.VerifyString(instanceSpecifier()) &&
           VerifyOffset(verifier, VT_PROCESSSHORTNAME) &&
           verifier.VerifyString(processShortName()) &&
           VerifyOffset(verifier, VT_PORTPROTOTYPE) &&
           verifier.VerifyString(portPrototype()) &&
           VerifyOffset(verifier, VT_INTERFACEPATH) &&
           verifier.VerifyString(interfacePath()) &&
           VerifyField<uint32_t>(verifier, VT_REFPROCESSINDEX, 4) &&
           VerifyField<int32_t>(verifier, VT_PERMITTEDUID, 4) &&
           verifier.EndTable();
  }
};

struct HmMonitorInterfaceBuilder {
  typedef HmMonitorInterface Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_instanceSpecifier(::flatbuffers::Offset<::flatbuffers::String> instanceSpecifier) {
    fbb_.AddOffset(HmMonitorInterface::VT_INSTANCESPECIFIER, instanceSpecifier);
  }
  void add_processShortName(::flatbuffers::Offset<::flatbuffers::String> processShortName) {
    fbb_.AddOffset(HmMonitorInterface::VT_PROCESSSHORTNAME, processShortName);
  }
  void add_portPrototype(::flatbuffers::Offset<::flatbuffers::String> portPrototype) {
    fbb_.AddOffset(HmMonitorInterface::VT_PORTPROTOTYPE, portPrototype);
  }
  void add_interfacePath(::flatbuffers::Offset<::flatbuffers::String> interfacePath) {
    fbb_.AddOffset(HmMonitorInterface::VT_INTERFACEPATH, interfacePath);
  }
  void add_refProcessIndex(uint32_t refProcessIndex) {
    fbb_.AddElement<uint32_t>(HmMonitorInterface::VT_REFPROCESSINDEX, refProcessIndex, 0);
  }
  void add_permittedUid(int32_t permittedUid) {
    fbb_.AddElement<int32_t>(HmMonitorInterface::VT_PERMITTEDUID, permittedUid, 0);
  }
  explicit HmMonitorInterfaceBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<HmMonitorInterface> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<HmMonitorInterface>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<HmMonitorInterface> CreateHmMonitorInterface(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> instanceSpecifier = 0,
    ::flatbuffers::Offset<::flatbuffers::String> processShortName = 0,
    ::flatbuffers::Offset<::flatbuffers::String> portPrototype = 0,
    ::flatbuffers::Offset<::flatbuffers::String> interfacePath = 0,
    uint32_t refProcessIndex = 0,
    int32_t permittedUid = 0) {
  HmMonitorInterfaceBuilder builder_(_fbb);
  builder_.add_permittedUid(permittedUid);
  builder_.add_refProcessIndex(refProcessIndex);
  builder_.add_interfacePath(interfacePath);
  builder_.add_portPrototype(portPrototype);
  builder_.add_processShortName(processShortName);
  builder_.add_instanceSpecifier(instanceSpecifier);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<HmMonitorInterface> CreateHmMonitorInterfaceDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *instanceSpecifier = nullptr,
    const char *processShortName = nullptr,
    const char *portPrototype = nullptr,
    const char *interfacePath = nullptr,
    uint32_t refProcessIndex = 0,
    int32_t permittedUid = 0) {
  auto instanceSpecifier__ = instanceSpecifier ? _fbb.CreateString(instanceSpecifier) : 0;
  auto processShortName__ = processShortName ? _fbb.CreateString(processShortName) : 0;
  auto portPrototype__ = portPrototype ? _fbb.CreateString(portPrototype) : 0;
  auto interfacePath__ = interfacePath ? _fbb.CreateString(interfacePath) : 0;
  return HMFlatBuffer::CreateHmMonitorInterface(
      _fbb,
      instanceSpecifier__,
      processShortName__,
      portPrototype__,
      interfacePath__,
      refProcessIndex,
      permittedUid);
}

struct HmSupervisionCheckpoint FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef HmSupervisionCheckpointBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SHORTNAME = 4,
    VT_CHECKPOINTID = 6,
    VT_REFINTERFACEINDEX = 8
  };
  const ::flatbuffers::String *shortName() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SHORTNAME);
  }
  uint32_t checkpointId() const {
    return GetField<uint32_t>(VT_CHECKPOINTID, 0);
  }
  uint32_t refInterfaceIndex() const {
    return GetField<uint32_t>(VT_REFINTERFACEINDEX, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SHORTNAME) &&
           verifier.VerifyString(shortName()) &&
           VerifyField<uint32_t>(verifier, VT_CHECKPOINTID, 4) &&
           VerifyField<uint32_t>(verifier, VT_REFINTERFACEINDEX, 4) &&
           verifier.EndTable();
  }
};

struct HmSupervisionCheckpointBuilder {
  typedef HmSupervisionCheckpoint Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_shortName(::flatbuffers::Offset<::flatbuffers::String> shortName) {
    fbb_.AddOffset(HmSupervisionCheckpoint::VT_SHORTNAME, shortName);
  }
  void add_checkpointId(uint32_t checkpointId) {
    fbb_.AddElement<uint32_t>(HmSupervisionCheckpoint::VT_CHECKPOINTID, checkpointId, 0);
  }
  void add_refInterfaceIndex(uint32_t refInterfaceIndex) {
    fbb_.AddElement<uint32_t>(HmSupervisionCheckpoint::VT_REFINTERFACEINDEX, refInterfaceIndex, 0);
  }
  explicit HmSupervisionCheckpointBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<HmSupervisionCheckpoint> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<HmSupervisionCheckpoint>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<HmSupervisionCheckpoint> CreateHmSupervisionCheckpoint(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> shortName = 0,
    uint32_t checkpointId = 0,
    uint32_t refInterfaceIndex = 0) {
  HmSupervisionCheckpointBuilder builder_(_fbb);
  builder_.add_refInterfaceIndex(refInterfaceIndex);
  builder_.add_checkpointId(checkpointId);
  builder_.add_shortName(shortName);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<HmSupervisionCheckpoint> CreateHmSupervisionCheckpointDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *shortName = nullptr,
    uint32_t checkpointId = 0,
    uint32_t refInterfaceIndex = 0) {
  auto shortName__ = shortName ? _fbb.CreateString(shortName) : 0;
  return HMFlatBuffer::CreateHmSupervisionCheckpoint(
      _fbb,
      shortName__,
      checkpointId,
      refInterfaceIndex);
}

struct HmCheckpointTransition FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef HmCheckpointTransitionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_REFSOURCECPINDEX = 4,
    VT_REFTARGETCPINDEX = 6,
    VT_INFOSOURCE = 8,
    VT_INFOTARGET = 10
  };
  uint32_t refSourceCPIndex() const {
    return GetField<uint32_t>(VT_REFSOURCECPINDEX, 0);
  }
  uint32_t refTargetCPIndex() const {
    return GetField<uint32_t>(VT_REFTARGETCPINDEX, 0);
  }
  const HMFlatBuffer::HmSupervisionCheckpoint *infoSource() const {
    return GetPointer<const HMFlatBuffer::HmSupervisionCheckpoint *>(VT_INFOSOURCE);
  }
  const HMFlatBuffer::HmSupervisionCheckpoint *infoTarget() const {
    return GetPointer<const HMFlatBuffer::HmSupervisionCheckpoint *>(VT_INFOTARGET);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_REFSOURCECPINDEX, 4) &&
           VerifyField<uint32_t>(verifier, VT_REFTARGETCPINDEX, 4) &&
           VerifyOffset(verifier, VT_INFOSOURCE) &&
           verifier.VerifyTable(infoSource()) &&
           VerifyOffset(verifier, VT_INFOTARGET) &&
           verifier.VerifyTable(infoTarget()) &&
           verifier.EndTable();
  }
};

struct HmCheckpointTransitionBuilder {
  typedef HmCheckpointTransition Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_refSourceCPIndex(uint32_t refSourceCPIndex) {
    fbb_.AddElement<uint32_t>(HmCheckpointTransition::VT_REFSOURCECPINDEX, refSourceCPIndex, 0);
  }
  void add_refTargetCPIndex(uint32_t refTargetCPIndex) {
    fbb_.AddElement<uint32_t>(HmCheckpointTransition::VT_REFTARGETCPINDEX, refTargetCPIndex, 0);
  }
  void add_infoSource(::flatbuffers::Offset<HMFlatBuffer::HmSupervisionCheckpoint> infoSource) {
    fbb_.AddOffset(HmCheckpointTransition::VT_INFOSOURCE, infoSource);
  }
  void add_infoTarget(::flatbuffers::Offset<HMFlatBuffer::HmSupervisionCheckpoint> infoTarget) {
    fbb_.AddOffset(HmCheckpointTransition::VT_INFOTARGET, infoTarget);
  }
  explicit HmCheckpointTransitionBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<HmCheckpointTransition> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<HmCheckpointTransition>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<HmCheckpointTransition> CreateHmCheckpointTransition(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t refSourceCPIndex = 0,
    uint32_t refTargetCPIndex = 0,
    ::flatbuffers::Offset<HMFlatBuffer::HmSupervisionCheckpoint> infoSource = 0,
    ::flatbuffers::Offset<HMFlatBuffer::HmSupervisionCheckpoint> infoTarget = 0) {
  HmCheckpointTransitionBuilder builder_(_fbb);
  builder_.add_infoTarget(infoTarget);
  builder_.add_infoSource(infoSource);
  builder_.add_refTargetCPIndex(refTargetCPIndex);
  builder_.add_refSourceCPIndex(refSourceCPIndex);
  return builder_.Finish();
}

struct HmAliveSupervision FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef HmAliveSupervisionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RULECONTEXTKEY = 4,
    VT_REFCHECKPOINTINDEX = 6,
    VT_ALIVEREFERENCECYCLE = 8,
    VT_MINALIVEINDICATIONS = 10,
    VT_MAXALIVEINDICATIONS = 12,
    VT_ISMINCHECKDISABLED = 14,
    VT_ISMAXCHECKDISABLED = 16,
    VT_FAILEDSUPERVISIONCYCLESTOLERANCE = 18,
    VT_REFPROCESSINDEX = 20,
    VT_REFPROCESSGROUPSTATES = 22
  };
  const ::flatbuffers::String *ruleContextKey() const {
    return GetPointer<const ::flatbuffers::String *>(VT_RULECONTEXTKEY);
  }
  uint32_t refCheckPointIndex() const {
    return GetField<uint32_t>(VT_REFCHECKPOINTINDEX, 0);
  }
  double aliveReferenceCycle() const {
    return GetField<double>(VT_ALIVEREFERENCECYCLE, 0.0);
  }
  uint32_t minAliveIndications() const {
    return GetField<uint32_t>(VT_MINALIVEINDICATIONS, 0);
  }
  uint32_t maxAliveIndications() const {
    return GetField<uint32_t>(VT_MAXALIVEINDICATIONS, 0);
  }
  bool isMinCheckDisabled() const {
    return GetField<uint8_t>(VT_ISMINCHECKDISABLED, 0) != 0;
  }
  bool isMaxCheckDisabled() const {
    return GetField<uint8_t>(VT_ISMAXCHECKDISABLED, 0) != 0;
  }
  uint32_t failedSupervisionCyclesTolerance() const {
    return GetField<uint32_t>(VT_FAILEDSUPERVISIONCYCLESTOLERANCE, 0);
  }
  uint32_t refProcessIndex() const {
    return GetField<uint32_t>(VT_REFPROCESSINDEX, 0);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<HMFlatBuffer::HmRefProcessGroupStates>> *refProcessGroupStates() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<HMFlatBuffer::HmRefProcessGroupStates>> *>(VT_REFPROCESSGROUPSTATES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_RULECONTEXTKEY) &&
           verifier.VerifyString(ruleContextKey()) &&
           VerifyField<uint32_t>(verifier, VT_REFCHECKPOINTINDEX, 4) &&
           VerifyField<double>(verifier, VT_ALIVEREFERENCECYCLE, 8) &&
           VerifyField<uint32_t>(verifier, VT_MINALIVEINDICATIONS, 4) &&
           VerifyField<uint32_t>(verifier, VT_MAXALIVEINDICATIONS, 4) &&
           VerifyField<uint8_t>(verifier, VT_ISMINCHECKDISABLED, 1) &&
           VerifyField<uint8_t>(verifier, VT_ISMAXCHECKDISABLED, 1) &&
           VerifyField<uint32_t>(verifier, VT_FAILEDSUPERVISIONCYCLESTOLERANCE, 4) &&
           VerifyField<uint32_t>(verifier, VT_REFPROCESSINDEX, 4) &&
           VerifyOffset(verifier, VT_REFPROCESSGROUPSTATES) &&
           verifier.VerifyVector(refProcessGroupStates()) &&
           verifier.VerifyVectorOfTables(refProcessGroupStates()) &&
           verifier.EndTable();
  }
};

struct HmAliveSupervisionBuilder {
  typedef HmAliveSupervision Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_ruleContextKey(::flatbuffers::Offset<::flatbuffers::String> ruleContextKey) {
    fbb_.AddOffset(HmAliveSupervision::VT_RULECONTEXTKEY, ruleContextKey);
  }
  void add_refCheckPointIndex(uint32_t refCheckPointIndex) {
    fbb_.AddElement<uint32_t>(HmAliveSupervision::VT_REFCHECKPOINTINDEX, refCheckPointIndex, 0);
  }
  void add_aliveReferenceCycle(double aliveReferenceCycle) {
    fbb_.AddElement<double>(HmAliveSupervision::VT_ALIVEREFERENCECYCLE, aliveReferenceCycle, 0.0);
  }
  void add_minAliveIndications(uint32_t minAliveIndications) {
    fbb_.AddElement<uint32_t>(HmAliveSupervision::VT_MINALIVEINDICATIONS, minAliveIndications, 0);
  }
  void add_maxAliveIndications(uint32_t maxAliveIndications) {
    fbb_.AddElement<uint32_t>(HmAliveSupervision::VT_MAXALIVEINDICATIONS, maxAliveIndications, 0);
  }
  void add_isMinCheckDisabled(bool isMinCheckDisabled) {
    fbb_.AddElement<uint8_t>(HmAliveSupervision::VT_ISMINCHECKDISABLED, static_cast<uint8_t>(isMinCheckDisabled), 0);
  }
  void add_isMaxCheckDisabled(bool isMaxCheckDisabled) {
    fbb_.AddElement<uint8_t>(HmAliveSupervision::VT_ISMAXCHECKDISABLED, static_cast<uint8_t>(isMaxCheckDisabled), 0);
  }
  void add_failedSupervisionCyclesTolerance(uint32_t failedSupervisionCyclesTolerance) {
    fbb_.AddElement<uint32_t>(HmAliveSupervision::VT_FAILEDSUPERVISIONCYCLESTOLERANCE, failedSupervisionCyclesTolerance, 0);
  }
  void add_refProcessIndex(uint32_t refProcessIndex) {
    fbb_.AddElement<uint32_t>(HmAliveSupervision::VT_REFPROCESSINDEX, refProcessIndex, 0);
  }
  void add_refProcessGroupStates(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<HMFlatBuffer::HmRefProcessGroupStates>>> refProcessGroupStates) {
    fbb_.AddOffset(HmAliveSupervision::VT_REFPROCESSGROUPSTATES, refProcessGroupStates);
  }
  explicit HmAliveSupervisionBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<HmAliveSupervision> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<HmAliveSupervision>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<HmAliveSupervision> CreateHmAliveSupervision(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> ruleContextKey = 0,
    uint32_t refCheckPointIndex = 0,
    double aliveReferenceCycle = 0.0,
    uint32_t minAliveIndications = 0,
    uint32_t maxAliveIndications = 0,
    bool isMinCheckDisabled = false,
    bool isMaxCheckDisabled = false,
    uint32_t failedSupervisionCyclesTolerance = 0,
    uint32_t refProcessIndex = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<HMFlatBuffer::HmRefProcessGroupStates>>> refProcessGroupStates = 0) {
  HmAliveSupervisionBuilder builder_(_fbb);
  builder_.add_aliveReferenceCycle(aliveReferenceCycle);
  builder_.add_refProcessGroupStates(refProcessGroupStates);
  builder_.add_refProcessIndex(refProcessIndex);
  builder_.add_failedSupervisionCyclesTolerance(failedSupervisionCyclesTolerance);
  builder_.add_maxAliveIndications(maxAliveIndications);
  builder_.add_minAliveIndications(minAliveIndications);
  builder_.add_refCheckPointIndex(refCheckPointIndex);
  builder_.add_ruleContextKey(ruleContextKey);
  builder_.add_isMaxCheckDisabled(isMaxCheckDisabled);
  builder_.add_isMinCheckDisabled(isMinCheckDisabled);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<HmAliveSupervision> CreateHmAliveSupervisionDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *ruleContextKey = nullptr,
    uint32_t refCheckPointIndex = 0,
    double aliveReferenceCycle = 0.0,
    uint32_t minAliveIndications = 0,
    uint32_t maxAliveIndications = 0,
    bool isMinCheckDisabled = false,
    bool isMaxCheckDisabled = false,
    uint32_t failedSupervisionCyclesTolerance = 0,
    uint32_t refProcessIndex = 0,
    const std::vector<::flatbuffers::Offset<HMFlatBuffer::HmRefProcessGroupStates>> *refProcessGroupStates = nullptr) {
  auto ruleContextKey__ = ruleContextKey ? _fbb.CreateString(ruleContextKey) : 0;
  auto refProcessGroupStates__ = refProcessGroupStates ? _fbb.CreateVector<::flatbuffers::Offset<HMFlatBuffer::HmRefProcessGroupStates>>(*refProcessGroupStates) : 0;
  return HMFlatBuffer::CreateHmAliveSupervision(
      _fbb,
      ruleContextKey__,
      refCheckPointIndex,
      aliveReferenceCycle,
      minAliveIndications,
      maxAliveIndications,
      isMinCheckDisabled,
      isMaxCheckDisabled,
      failedSupervisionCyclesTolerance,
      refProcessIndex,
      refProcessGroupStates__);
}

struct HmDeadlineSupervision FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef HmDeadlineSupervisionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RULECONTEXTKEY = 4,
    VT_MAXDEADLINE = 6,
    VT_MINDEADLINE = 8,
    VT_CHECKPOINTTRANSITION = 10,
    VT_REFPROCESSINDICES = 12,
    VT_REFPROCESSGROUPSTATES = 14
  };
  const ::flatbuffers::String *ruleContextKey() const {
    return GetPointer<const ::flatbuffers::String *>(VT_RULECONTEXTKEY);
  }
  double maxDeadline() const {
    return GetField<double>(VT_MAXDEADLINE, 0.0);
  }
  double minDeadline() const {
    return GetField<double>(VT_MINDEADLINE, 0.0);
  }
  const HMFlatBuffer::HmCheckpointTransition *checkpointTransition() const {
    return GetPointer<const HMFlatBuffer::HmCheckpointTransition *>(VT_CHECKPOINTTRANSITION);
  }
  const ::flatbuffers::Vector<uint32_t> *refProcessIndices() const {
    return GetPointer<const ::flatbuffers::Vector<uint32_t> *>(VT_REFPROCESSINDICES);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<HMFlatBuffer::HmRefProcessGroupStates>> *refProcessGroupStates() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<HMFlatBuffer::HmRefProcessGroupStates>> *>(VT_REFPROCESSGROUPSTATES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_RULECONTEXTKEY) &&
           verifier.VerifyString(ruleContextKey()) &&
           VerifyField<double>(verifier, VT_MAXDEADLINE, 8) &&
           VerifyField<double>(verifier, VT_MINDEADLINE, 8) &&
           VerifyOffset(verifier, VT_CHECKPOINTTRANSITION) &&
           verifier.VerifyTable(checkpointTransition()) &&
           VerifyOffset(verifier, VT_REFPROCESSINDICES) &&
           verifier.VerifyVector(refProcessIndices()) &&
           VerifyOffset(verifier, VT_REFPROCESSGROUPSTATES) &&
           verifier.VerifyVector(refProcessGroupStates()) &&
           verifier.VerifyVectorOfTables(refProcessGroupStates()) &&
           verifier.EndTable();
  }
};

struct HmDeadlineSupervisionBuilder {
  typedef HmDeadlineSupervision Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_ruleContextKey(::flatbuffers::Offset<::flatbuffers::String> ruleContextKey) {
    fbb_.AddOffset(HmDeadlineSupervision::VT_RULECONTEXTKEY, ruleContextKey);
  }
  void add_maxDeadline(double maxDeadline) {
    fbb_.AddElement<double>(HmDeadlineSupervision::VT_MAXDEADLINE, maxDeadline, 0.0);
  }
  void add_minDeadline(double minDeadline) {
    fbb_.AddElement<double>(HmDeadlineSupervision::VT_MINDEADLINE, minDeadline, 0.0);
  }
  void add_checkpointTransition(::flatbuffers::Offset<HMFlatBuffer::HmCheckpointTransition> checkpointTransition) {
    fbb_.AddOffset(HmDeadlineSupervision::VT_CHECKPOINTTRANSITION, checkpointTransition);
  }
  void add_refProcessIndices(::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> refProcessIndices) {
    fbb_.AddOffset(HmDeadlineSupervision::VT_REFPROCESSINDICES, refProcessIndices);
  }
  void add_refProcessGroupStates(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<HMFlatBuffer::HmRefProcessGroupStates>>> refProcessGroupStates) {
    fbb_.AddOffset(HmDeadlineSupervision::VT_REFPROCESSGROUPSTATES, refProcessGroupStates);
  }
  explicit HmDeadlineSupervisionBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<HmDeadlineSupervision> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<HmDeadlineSupervision>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<HmDeadlineSupervision> CreateHmDeadlineSupervision(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> ruleContextKey = 0,
    double maxDeadline = 0.0,
    double minDeadline = 0.0,
    ::flatbuffers::Offset<HMFlatBuffer::HmCheckpointTransition> checkpointTransition = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> refProcessIndices = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<HMFlatBuffer::HmRefProcessGroupStates>>> refProcessGroupStates = 0) {
  HmDeadlineSupervisionBuilder builder_(_fbb);
  builder_.add_minDeadline(minDeadline);
  builder_.add_maxDeadline(maxDeadline);
  builder_.add_refProcessGroupStates(refProcessGroupStates);
  builder_.add_refProcessIndices(refProcessIndices);
  builder_.add_checkpointTransition(checkpointTransition);
  builder_.add_ruleContextKey(ruleContextKey);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<HmDeadlineSupervision> CreateHmDeadlineSupervisionDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *ruleContextKey = nullptr,
    double maxDeadline = 0.0,
    double minDeadline = 0.0,
    ::flatbuffers::Offset<HMFlatBuffer::HmCheckpointTransition> checkpointTransition = 0,
    const std::vector<uint32_t> *refProcessIndices = nullptr,
    const std::vector<::flatbuffers::Offset<HMFlatBuffer::HmRefProcessGroupStates>> *refProcessGroupStates = nullptr) {
  auto ruleContextKey__ = ruleContextKey ? _fbb.CreateString(ruleContextKey) : 0;
  auto refProcessIndices__ = refProcessIndices ? _fbb.CreateVector<uint32_t>(*refProcessIndices) : 0;
  auto refProcessGroupStates__ = refProcessGroupStates ? _fbb.CreateVector<::flatbuffers::Offset<HMFlatBuffer::HmRefProcessGroupStates>>(*refProcessGroupStates) : 0;
  return HMFlatBuffer::CreateHmDeadlineSupervision(
      _fbb,
      ruleContextKey__,
      maxDeadline,
      minDeadline,
      checkpointTransition,
      refProcessIndices__,
      refProcessGroupStates__);
}

struct HmLogicalSupervision FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef HmLogicalSupervisionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RULECONTEXTKEY = 4,
    VT_CHECKPOINTS = 6,
    VT_TRANSITIONS = 8,
    VT_REFPROCESSINDICES = 10,
    VT_REFPROCESSGROUPSTATES = 12
  };
  const ::flatbuffers::String *ruleContextKey() const {
    return GetPointer<const ::flatbuffers::String *>(VT_RULECONTEXTKEY);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<HMFlatBuffer::HmLogicalCheckpoint>> *checkpoints() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<HMFlatBuffer::HmLogicalCheckpoint>> *>(VT_CHECKPOINTS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<HMFlatBuffer::HmLogicalTransition>> *transitions() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<HMFlatBuffer::HmLogicalTransition>> *>(VT_TRANSITIONS);
  }
  const ::flatbuffers::Vector<uint32_t> *refProcessIndices() const {
    return GetPointer<const ::flatbuffers::Vector<uint32_t> *>(VT_REFPROCESSINDICES);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<HMFlatBuffer::HmRefProcessGroupStates>> *refProcessGroupStates() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<HMFlatBuffer::HmRefProcessGroupStates>> *>(VT_REFPROCESSGROUPSTATES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_RULECONTEXTKEY) &&
           verifier.VerifyString(ruleContextKey()) &&
           VerifyOffset(verifier, VT_CHECKPOINTS) &&
           verifier.VerifyVector(checkpoints()) &&
           verifier.VerifyVectorOfTables(checkpoints()) &&
           VerifyOffset(verifier, VT_TRANSITIONS) &&
           verifier.VerifyVector(transitions()) &&
           verifier.VerifyVectorOfTables(transitions()) &&
           VerifyOffset(verifier, VT_REFPROCESSINDICES) &&
           verifier.VerifyVector(refProcessIndices()) &&
           VerifyOffset(verifier, VT_REFPROCESSGROUPSTATES) &&
           verifier.VerifyVector(refProcessGroupStates()) &&
           verifier.VerifyVectorOfTables(refProcessGroupStates()) &&
           verifier.EndTable();
  }
};

struct HmLogicalSupervisionBuilder {
  typedef HmLogicalSupervision Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_ruleContextKey(::flatbuffers::Offset<::flatbuffers::String> ruleContextKey) {
    fbb_.AddOffset(HmLogicalSupervision::VT_RULECONTEXTKEY, ruleContextKey);
  }
  void add_checkpoints(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<HMFlatBuffer::HmLogicalCheckpoint>>> checkpoints) {
    fbb_.AddOffset(HmLogicalSupervision::VT_CHECKPOINTS, checkpoints);
  }
  void add_transitions(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<HMFlatBuffer::HmLogicalTransition>>> transitions) {
    fbb_.AddOffset(HmLogicalSupervision::VT_TRANSITIONS, transitions);
  }
  void add_refProcessIndices(::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> refProcessIndices) {
    fbb_.AddOffset(HmLogicalSupervision::VT_REFPROCESSINDICES, refProcessIndices);
  }
  void add_refProcessGroupStates(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<HMFlatBuffer::HmRefProcessGroupStates>>> refProcessGroupStates) {
    fbb_.AddOffset(HmLogicalSupervision::VT_REFPROCESSGROUPSTATES, refProcessGroupStates);
  }
  explicit HmLogicalSupervisionBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<HmLogicalSupervision> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<HmLogicalSupervision>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<HmLogicalSupervision> CreateHmLogicalSupervision(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> ruleContextKey = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<HMFlatBuffer::HmLogicalCheckpoint>>> checkpoints = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<HMFlatBuffer::HmLogicalTransition>>> transitions = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> refProcessIndices = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<HMFlatBuffer::HmRefProcessGroupStates>>> refProcessGroupStates = 0) {
  HmLogicalSupervisionBuilder builder_(_fbb);
  builder_.add_refProcessGroupStates(refProcessGroupStates);
  builder_.add_refProcessIndices(refProcessIndices);
  builder_.add_transitions(transitions);
  builder_.add_checkpoints(checkpoints);
  builder_.add_ruleContextKey(ruleContextKey);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<HmLogicalSupervision> CreateHmLogicalSupervisionDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *ruleContextKey = nullptr,
    const std::vector<::flatbuffers::Offset<HMFlatBuffer::HmLogicalCheckpoint>> *checkpoints = nullptr,
    const std::vector<::flatbuffers::Offset<HMFlatBuffer::HmLogicalTransition>> *transitions = nullptr,
    const std::vector<uint32_t> *refProcessIndices = nullptr,
    const std::vector<::flatbuffers::Offset<HMFlatBuffer::HmRefProcessGroupStates>> *refProcessGroupStates = nullptr) {
  auto ruleContextKey__ = ruleContextKey ? _fbb.CreateString(ruleContextKey) : 0;
  auto checkpoints__ = checkpoints ? _fbb.CreateVector<::flatbuffers::Offset<HMFlatBuffer::HmLogicalCheckpoint>>(*checkpoints) : 0;
  auto transitions__ = transitions ? _fbb.CreateVector<::flatbuffers::Offset<HMFlatBuffer::HmLogicalTransition>>(*transitions) : 0;
  auto refProcessIndices__ = refProcessIndices ? _fbb.CreateVector<uint32_t>(*refProcessIndices) : 0;
  auto refProcessGroupStates__ = refProcessGroupStates ? _fbb.CreateVector<::flatbuffers::Offset<HMFlatBuffer::HmRefProcessGroupStates>>(*refProcessGroupStates) : 0;
  return HMFlatBuffer::CreateHmLogicalSupervision(
      _fbb,
      ruleContextKey__,
      checkpoints__,
      transitions__,
      refProcessIndices__,
      refProcessGroupStates__);
}

struct HmLogicalCheckpoint FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef HmLogicalCheckpointBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_REFCHECKPOINTINDEX = 4,
    VT_ISINITIAL = 6,
    VT_ISFINAL = 8
  };
  uint32_t refCheckPointIndex() const {
    return GetField<uint32_t>(VT_REFCHECKPOINTINDEX, 0);
  }
  bool isInitial() const {
    return GetField<uint8_t>(VT_ISINITIAL, 0) != 0;
  }
  bool isFinal() const {
    return GetField<uint8_t>(VT_ISFINAL, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_REFCHECKPOINTINDEX, 4) &&
           VerifyField<uint8_t>(verifier, VT_ISINITIAL, 1) &&
           VerifyField<uint8_t>(verifier, VT_ISFINAL, 1) &&
           verifier.EndTable();
  }
};

struct HmLogicalCheckpointBuilder {
  typedef HmLogicalCheckpoint Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_refCheckPointIndex(uint32_t refCheckPointIndex) {
    fbb_.AddElement<uint32_t>(HmLogicalCheckpoint::VT_REFCHECKPOINTINDEX, refCheckPointIndex, 0);
  }
  void add_isInitial(bool isInitial) {
    fbb_.AddElement<uint8_t>(HmLogicalCheckpoint::VT_ISINITIAL, static_cast<uint8_t>(isInitial), 0);
  }
  void add_isFinal(bool isFinal) {
    fbb_.AddElement<uint8_t>(HmLogicalCheckpoint::VT_ISFINAL, static_cast<uint8_t>(isFinal), 0);
  }
  explicit HmLogicalCheckpointBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<HmLogicalCheckpoint> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<HmLogicalCheckpoint>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<HmLogicalCheckpoint> CreateHmLogicalCheckpoint(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t refCheckPointIndex = 0,
    bool isInitial = false,
    bool isFinal = false) {
  HmLogicalCheckpointBuilder builder_(_fbb);
  builder_.add_refCheckPointIndex(refCheckPointIndex);
  builder_.add_isFinal(isFinal);
  builder_.add_isInitial(isInitial);
  return builder_.Finish();
}

struct HmLogicalTransition FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef HmLogicalTransitionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CHECKPOINTSOURCEIDX = 4,
    VT_CHECKPOINTTARGETIDX = 6
  };
  uint32_t checkpointSourceIdx() const {
    return GetField<uint32_t>(VT_CHECKPOINTSOURCEIDX, 0);
  }
  uint32_t checkpointTargetIdx() const {
    return GetField<uint32_t>(VT_CHECKPOINTTARGETIDX, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_CHECKPOINTSOURCEIDX, 4) &&
           VerifyField<uint32_t>(verifier, VT_CHECKPOINTTARGETIDX, 4) &&
           verifier.EndTable();
  }
};

struct HmLogicalTransitionBuilder {
  typedef HmLogicalTransition Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_checkpointSourceIdx(uint32_t checkpointSourceIdx) {
    fbb_.AddElement<uint32_t>(HmLogicalTransition::VT_CHECKPOINTSOURCEIDX, checkpointSourceIdx, 0);
  }
  void add_checkpointTargetIdx(uint32_t checkpointTargetIdx) {
    fbb_.AddElement<uint32_t>(HmLogicalTransition::VT_CHECKPOINTTARGETIDX, checkpointTargetIdx, 0);
  }
  explicit HmLogicalTransitionBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<HmLogicalTransition> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<HmLogicalTransition>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<HmLogicalTransition> CreateHmLogicalTransition(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t checkpointSourceIdx = 0,
    uint32_t checkpointTargetIdx = 0) {
  HmLogicalTransitionBuilder builder_(_fbb);
  builder_.add_checkpointTargetIdx(checkpointTargetIdx);
  builder_.add_checkpointSourceIdx(checkpointSourceIdx);
  return builder_.Finish();
}

struct HmLocalSupervision FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef HmLocalSupervisionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RULECONTEXTKEY = 4,
    VT_INFOREFINTERFACEPATH = 6,
    VT_HMREFALIVESUPERVISION = 8,
    VT_HMREFDEADLINESUPERVISION = 10,
    VT_HMREFLOGICALSUPERVISION = 12
  };
  const ::flatbuffers::String *ruleContextKey() const {
    return GetPointer<const ::flatbuffers::String *>(VT_RULECONTEXTKEY);
  }
  const ::flatbuffers::String *infoRefInterfacePath() const {
    return GetPointer<const ::flatbuffers::String *>(VT_INFOREFINTERFACEPATH);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<HMFlatBuffer::HmRefAliveSupervision>> *hmRefAliveSupervision() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<HMFlatBuffer::HmRefAliveSupervision>> *>(VT_HMREFALIVESUPERVISION);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<HMFlatBuffer::HmRefDeadlineSupervision>> *hmRefDeadlineSupervision() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<HMFlatBuffer::HmRefDeadlineSupervision>> *>(VT_HMREFDEADLINESUPERVISION);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<HMFlatBuffer::HmRefLogicalSupervision>> *hmRefLogicalSupervision() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<HMFlatBuffer::HmRefLogicalSupervision>> *>(VT_HMREFLOGICALSUPERVISION);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_RULECONTEXTKEY) &&
           verifier.VerifyString(ruleContextKey()) &&
           VerifyOffset(verifier, VT_INFOREFINTERFACEPATH) &&
           verifier.VerifyString(infoRefInterfacePath()) &&
           VerifyOffset(verifier, VT_HMREFALIVESUPERVISION) &&
           verifier.VerifyVector(hmRefAliveSupervision()) &&
           verifier.VerifyVectorOfTables(hmRefAliveSupervision()) &&
           VerifyOffset(verifier, VT_HMREFDEADLINESUPERVISION) &&
           verifier.VerifyVector(hmRefDeadlineSupervision()) &&
           verifier.VerifyVectorOfTables(hmRefDeadlineSupervision()) &&
           VerifyOffset(verifier, VT_HMREFLOGICALSUPERVISION) &&
           verifier.VerifyVector(hmRefLogicalSupervision()) &&
           verifier.VerifyVectorOfTables(hmRefLogicalSupervision()) &&
           verifier.EndTable();
  }
};

struct HmLocalSupervisionBuilder {
  typedef HmLocalSupervision Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_ruleContextKey(::flatbuffers::Offset<::flatbuffers::String> ruleContextKey) {
    fbb_.AddOffset(HmLocalSupervision::VT_RULECONTEXTKEY, ruleContextKey);
  }
  void add_infoRefInterfacePath(::flatbuffers::Offset<::flatbuffers::String> infoRefInterfacePath) {
    fbb_.AddOffset(HmLocalSupervision::VT_INFOREFINTERFACEPATH, infoRefInterfacePath);
  }
  void add_hmRefAliveSupervision(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<HMFlatBuffer::HmRefAliveSupervision>>> hmRefAliveSupervision) {
    fbb_.AddOffset(HmLocalSupervision::VT_HMREFALIVESUPERVISION, hmRefAliveSupervision);
  }
  void add_hmRefDeadlineSupervision(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<HMFlatBuffer::HmRefDeadlineSupervision>>> hmRefDeadlineSupervision) {
    fbb_.AddOffset(HmLocalSupervision::VT_HMREFDEADLINESUPERVISION, hmRefDeadlineSupervision);
  }
  void add_hmRefLogicalSupervision(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<HMFlatBuffer::HmRefLogicalSupervision>>> hmRefLogicalSupervision) {
    fbb_.AddOffset(HmLocalSupervision::VT_HMREFLOGICALSUPERVISION, hmRefLogicalSupervision);
  }
  explicit HmLocalSupervisionBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<HmLocalSupervision> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<HmLocalSupervision>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<HmLocalSupervision> CreateHmLocalSupervision(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> ruleContextKey = 0,
    ::flatbuffers::Offset<::flatbuffers::String> infoRefInterfacePath = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<HMFlatBuffer::HmRefAliveSupervision>>> hmRefAliveSupervision = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<HMFlatBuffer::HmRefDeadlineSupervision>>> hmRefDeadlineSupervision = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<HMFlatBuffer::HmRefLogicalSupervision>>> hmRefLogicalSupervision = 0) {
  HmLocalSupervisionBuilder builder_(_fbb);
  builder_.add_hmRefLogicalSupervision(hmRefLogicalSupervision);
  builder_.add_hmRefDeadlineSupervision(hmRefDeadlineSupervision);
  builder_.add_hmRefAliveSupervision(hmRefAliveSupervision);
  builder_.add_infoRefInterfacePath(infoRefInterfacePath);
  builder_.add_ruleContextKey(ruleContextKey);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<HmLocalSupervision> CreateHmLocalSupervisionDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *ruleContextKey = nullptr,
    const char *infoRefInterfacePath = nullptr,
    const std::vector<::flatbuffers::Offset<HMFlatBuffer::HmRefAliveSupervision>> *hmRefAliveSupervision = nullptr,
    const std::vector<::flatbuffers::Offset<HMFlatBuffer::HmRefDeadlineSupervision>> *hmRefDeadlineSupervision = nullptr,
    const std::vector<::flatbuffers::Offset<HMFlatBuffer::HmRefLogicalSupervision>> *hmRefLogicalSupervision = nullptr) {
  auto ruleContextKey__ = ruleContextKey ? _fbb.CreateString(ruleContextKey) : 0;
  auto infoRefInterfacePath__ = infoRefInterfacePath ? _fbb.CreateString(infoRefInterfacePath) : 0;
  auto hmRefAliveSupervision__ = hmRefAliveSupervision ? _fbb.CreateVector<::flatbuffers::Offset<HMFlatBuffer::HmRefAliveSupervision>>(*hmRefAliveSupervision) : 0;
  auto hmRefDeadlineSupervision__ = hmRefDeadlineSupervision ? _fbb.CreateVector<::flatbuffers::Offset<HMFlatBuffer::HmRefDeadlineSupervision>>(*hmRefDeadlineSupervision) : 0;
  auto hmRefLogicalSupervision__ = hmRefLogicalSupervision ? _fbb.CreateVector<::flatbuffers::Offset<HMFlatBuffer::HmRefLogicalSupervision>>(*hmRefLogicalSupervision) : 0;
  return HMFlatBuffer::CreateHmLocalSupervision(
      _fbb,
      ruleContextKey__,
      infoRefInterfacePath__,
      hmRefAliveSupervision__,
      hmRefDeadlineSupervision__,
      hmRefLogicalSupervision__);
}

struct HmRefAliveSupervision FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef HmRefAliveSupervisionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RULECONTEXTKEY = 4,
    VT_REFALIVESUPERVISIONIDX = 6
  };
  int32_t ruleContextKey() const {
    return GetField<int32_t>(VT_RULECONTEXTKEY, 0);
  }
  uint32_t refAliveSupervisionIdx() const {
    return GetField<uint32_t>(VT_REFALIVESUPERVISIONIDX, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_RULECONTEXTKEY, 4) &&
           VerifyField<uint32_t>(verifier, VT_REFALIVESUPERVISIONIDX, 4) &&
           verifier.EndTable();
  }
};

struct HmRefAliveSupervisionBuilder {
  typedef HmRefAliveSupervision Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_ruleContextKey(int32_t ruleContextKey) {
    fbb_.AddElement<int32_t>(HmRefAliveSupervision::VT_RULECONTEXTKEY, ruleContextKey, 0);
  }
  void add_refAliveSupervisionIdx(uint32_t refAliveSupervisionIdx) {
    fbb_.AddElement<uint32_t>(HmRefAliveSupervision::VT_REFALIVESUPERVISIONIDX, refAliveSupervisionIdx, 0);
  }
  explicit HmRefAliveSupervisionBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<HmRefAliveSupervision> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<HmRefAliveSupervision>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<HmRefAliveSupervision> CreateHmRefAliveSupervision(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t ruleContextKey = 0,
    uint32_t refAliveSupervisionIdx = 0) {
  HmRefAliveSupervisionBuilder builder_(_fbb);
  builder_.add_refAliveSupervisionIdx(refAliveSupervisionIdx);
  builder_.add_ruleContextKey(ruleContextKey);
  return builder_.Finish();
}

struct HmRefDeadlineSupervision FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef HmRefDeadlineSupervisionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RULECONTEXTKEY = 4,
    VT_REFDEADLINESUPERVISIONIDX = 6
  };
  int32_t ruleContextKey() const {
    return GetField<int32_t>(VT_RULECONTEXTKEY, 0);
  }
  uint32_t refDeadlineSupervisionIdx() const {
    return GetField<uint32_t>(VT_REFDEADLINESUPERVISIONIDX, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_RULECONTEXTKEY, 4) &&
           VerifyField<uint32_t>(verifier, VT_REFDEADLINESUPERVISIONIDX, 4) &&
           verifier.EndTable();
  }
};

struct HmRefDeadlineSupervisionBuilder {
  typedef HmRefDeadlineSupervision Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_ruleContextKey(int32_t ruleContextKey) {
    fbb_.AddElement<int32_t>(HmRefDeadlineSupervision::VT_RULECONTEXTKEY, ruleContextKey, 0);
  }
  void add_refDeadlineSupervisionIdx(uint32_t refDeadlineSupervisionIdx) {
    fbb_.AddElement<uint32_t>(HmRefDeadlineSupervision::VT_REFDEADLINESUPERVISIONIDX, refDeadlineSupervisionIdx, 0);
  }
  explicit HmRefDeadlineSupervisionBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<HmRefDeadlineSupervision> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<HmRefDeadlineSupervision>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<HmRefDeadlineSupervision> CreateHmRefDeadlineSupervision(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t ruleContextKey = 0,
    uint32_t refDeadlineSupervisionIdx = 0) {
  HmRefDeadlineSupervisionBuilder builder_(_fbb);
  builder_.add_refDeadlineSupervisionIdx(refDeadlineSupervisionIdx);
  builder_.add_ruleContextKey(ruleContextKey);
  return builder_.Finish();
}

struct HmRefLogicalSupervision FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef HmRefLogicalSupervisionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_REFLOGICALSUPERVISIONIDX = 4
  };
  uint32_t refLogicalSupervisionIdx() const {
    return GetField<uint32_t>(VT_REFLOGICALSUPERVISIONIDX, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_REFLOGICALSUPERVISIONIDX, 4) &&
           verifier.EndTable();
  }
};

struct HmRefLogicalSupervisionBuilder {
  typedef HmRefLogicalSupervision Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_refLogicalSupervisionIdx(uint32_t refLogicalSupervisionIdx) {
    fbb_.AddElement<uint32_t>(HmRefLogicalSupervision::VT_REFLOGICALSUPERVISIONIDX, refLogicalSupervisionIdx, 0);
  }
  explicit HmRefLogicalSupervisionBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<HmRefLogicalSupervision> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<HmRefLogicalSupervision>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<HmRefLogicalSupervision> CreateHmRefLogicalSupervision(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t refLogicalSupervisionIdx = 0) {
  HmRefLogicalSupervisionBuilder builder_(_fbb);
  builder_.add_refLogicalSupervisionIdx(refLogicalSupervisionIdx);
  return builder_.Finish();
}

struct HmGlobalSupervision FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef HmGlobalSupervisionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RULECONTEXTKEY = 4,
    VT_ISSEVERITYCRITICAL = 6,
    VT_LOCALSUPERVISION = 8,
    VT_REFPROCESSES = 10,
    VT_REFPROCESSGROUPSTATES = 12
  };
  const ::flatbuffers::String *ruleContextKey() const {
    return GetPointer<const ::flatbuffers::String *>(VT_RULECONTEXTKEY);
  }
  bool isSeverityCritical() const {
    return GetField<uint8_t>(VT_ISSEVERITYCRITICAL, 0) != 0;
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<HMFlatBuffer::HmGlobalSupervisionLocalRef>> *localSupervision() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<HMFlatBuffer::HmGlobalSupervisionLocalRef>> *>(VT_LOCALSUPERVISION);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<HMFlatBuffer::HmRefProcess>> *refProcesses() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<HMFlatBuffer::HmRefProcess>> *>(VT_REFPROCESSES);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<HMFlatBuffer::HmRefProcessGroupStatesGlobal>> *refProcessGroupStates() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<HMFlatBuffer::HmRefProcessGroupStatesGlobal>> *>(VT_REFPROCESSGROUPSTATES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_RULECONTEXTKEY) &&
           verifier.VerifyString(ruleContextKey()) &&
           VerifyField<uint8_t>(verifier, VT_ISSEVERITYCRITICAL, 1) &&
           VerifyOffset(verifier, VT_LOCALSUPERVISION) &&
           verifier.VerifyVector(localSupervision()) &&
           verifier.VerifyVectorOfTables(localSupervision()) &&
           VerifyOffset(verifier, VT_REFPROCESSES) &&
           verifier.VerifyVector(refProcesses()) &&
           verifier.VerifyVectorOfTables(refProcesses()) &&
           VerifyOffset(verifier, VT_REFPROCESSGROUPSTATES) &&
           verifier.VerifyVector(refProcessGroupStates()) &&
           verifier.VerifyVectorOfTables(refProcessGroupStates()) &&
           verifier.EndTable();
  }
};

struct HmGlobalSupervisionBuilder {
  typedef HmGlobalSupervision Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_ruleContextKey(::flatbuffers::Offset<::flatbuffers::String> ruleContextKey) {
    fbb_.AddOffset(HmGlobalSupervision::VT_RULECONTEXTKEY, ruleContextKey);
  }
  void add_isSeverityCritical(bool isSeverityCritical) {
    fbb_.AddElement<uint8_t>(HmGlobalSupervision::VT_ISSEVERITYCRITICAL, static_cast<uint8_t>(isSeverityCritical), 0);
  }
  void add_localSupervision(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<HMFlatBuffer::HmGlobalSupervisionLocalRef>>> localSupervision) {
    fbb_.AddOffset(HmGlobalSupervision::VT_LOCALSUPERVISION, localSupervision);
  }
  void add_refProcesses(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<HMFlatBuffer::HmRefProcess>>> refProcesses) {
    fbb_.AddOffset(HmGlobalSupervision::VT_REFPROCESSES, refProcesses);
  }
  void add_refProcessGroupStates(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<HMFlatBuffer::HmRefProcessGroupStatesGlobal>>> refProcessGroupStates) {
    fbb_.AddOffset(HmGlobalSupervision::VT_REFPROCESSGROUPSTATES, refProcessGroupStates);
  }
  explicit HmGlobalSupervisionBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<HmGlobalSupervision> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<HmGlobalSupervision>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<HmGlobalSupervision> CreateHmGlobalSupervision(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> ruleContextKey = 0,
    bool isSeverityCritical = false,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<HMFlatBuffer::HmGlobalSupervisionLocalRef>>> localSupervision = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<HMFlatBuffer::HmRefProcess>>> refProcesses = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<HMFlatBuffer::HmRefProcessGroupStatesGlobal>>> refProcessGroupStates = 0) {
  HmGlobalSupervisionBuilder builder_(_fbb);
  builder_.add_refProcessGroupStates(refProcessGroupStates);
  builder_.add_refProcesses(refProcesses);
  builder_.add_localSupervision(localSupervision);
  builder_.add_ruleContextKey(ruleContextKey);
  builder_.add_isSeverityCritical(isSeverityCritical);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<HmGlobalSupervision> CreateHmGlobalSupervisionDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *ruleContextKey = nullptr,
    bool isSeverityCritical = false,
    const std::vector<::flatbuffers::Offset<HMFlatBuffer::HmGlobalSupervisionLocalRef>> *localSupervision = nullptr,
    const std::vector<::flatbuffers::Offset<HMFlatBuffer::HmRefProcess>> *refProcesses = nullptr,
    const std::vector<::flatbuffers::Offset<HMFlatBuffer::HmRefProcessGroupStatesGlobal>> *refProcessGroupStates = nullptr) {
  auto ruleContextKey__ = ruleContextKey ? _fbb.CreateString(ruleContextKey) : 0;
  auto localSupervision__ = localSupervision ? _fbb.CreateVector<::flatbuffers::Offset<HMFlatBuffer::HmGlobalSupervisionLocalRef>>(*localSupervision) : 0;
  auto refProcesses__ = refProcesses ? _fbb.CreateVector<::flatbuffers::Offset<HMFlatBuffer::HmRefProcess>>(*refProcesses) : 0;
  auto refProcessGroupStates__ = refProcessGroupStates ? _fbb.CreateVector<::flatbuffers::Offset<HMFlatBuffer::HmRefProcessGroupStatesGlobal>>(*refProcessGroupStates) : 0;
  return HMFlatBuffer::CreateHmGlobalSupervision(
      _fbb,
      ruleContextKey__,
      isSeverityCritical,
      localSupervision__,
      refProcesses__,
      refProcessGroupStates__);
}

struct HmGlobalSupervisionLocalRef FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef HmGlobalSupervisionLocalRefBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_REFLOCALSUPERVISIONINDEX = 4
  };
  uint32_t refLocalSupervisionIndex() const {
    return GetField<uint32_t>(VT_REFLOCALSUPERVISIONINDEX, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_REFLOCALSUPERVISIONINDEX, 4) &&
           verifier.EndTable();
  }
};

struct HmGlobalSupervisionLocalRefBuilder {
  typedef HmGlobalSupervisionLocalRef Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_refLocalSupervisionIndex(uint32_t refLocalSupervisionIndex) {
    fbb_.AddElement<uint32_t>(HmGlobalSupervisionLocalRef::VT_REFLOCALSUPERVISIONINDEX, refLocalSupervisionIndex, 0);
  }
  explicit HmGlobalSupervisionLocalRefBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<HmGlobalSupervisionLocalRef> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<HmGlobalSupervisionLocalRef>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<HmGlobalSupervisionLocalRef> CreateHmGlobalSupervisionLocalRef(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t refLocalSupervisionIndex = 0) {
  HmGlobalSupervisionLocalRefBuilder builder_(_fbb);
  builder_.add_refLocalSupervisionIndex(refLocalSupervisionIndex);
  return builder_.Finish();
}

struct HmRefProcessGroupStatesGlobal FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef HmRefProcessGroupStatesGlobalBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_IDENTIFIER = 4,
    VT_EXPIREDSUPERVISIONTOLERANCE = 6
  };
  const ::flatbuffers::String *identifier() const {
    return GetPointer<const ::flatbuffers::String *>(VT_IDENTIFIER);
  }
  double expiredSupervisionTolerance() const {
    return GetField<double>(VT_EXPIREDSUPERVISIONTOLERANCE, 0.0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_IDENTIFIER) &&
           verifier.VerifyString(identifier()) &&
           VerifyField<double>(verifier, VT_EXPIREDSUPERVISIONTOLERANCE, 8) &&
           verifier.EndTable();
  }
};

struct HmRefProcessGroupStatesGlobalBuilder {
  typedef HmRefProcessGroupStatesGlobal Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_identifier(::flatbuffers::Offset<::flatbuffers::String> identifier) {
    fbb_.AddOffset(HmRefProcessGroupStatesGlobal::VT_IDENTIFIER, identifier);
  }
  void add_expiredSupervisionTolerance(double expiredSupervisionTolerance) {
    fbb_.AddElement<double>(HmRefProcessGroupStatesGlobal::VT_EXPIREDSUPERVISIONTOLERANCE, expiredSupervisionTolerance, 0.0);
  }
  explicit HmRefProcessGroupStatesGlobalBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<HmRefProcessGroupStatesGlobal> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<HmRefProcessGroupStatesGlobal>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<HmRefProcessGroupStatesGlobal> CreateHmRefProcessGroupStatesGlobal(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> identifier = 0,
    double expiredSupervisionTolerance = 0.0) {
  HmRefProcessGroupStatesGlobalBuilder builder_(_fbb);
  builder_.add_expiredSupervisionTolerance(expiredSupervisionTolerance);
  builder_.add_identifier(identifier);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<HmRefProcessGroupStatesGlobal> CreateHmRefProcessGroupStatesGlobalDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *identifier = nullptr,
    double expiredSupervisionTolerance = 0.0) {
  auto identifier__ = identifier ? _fbb.CreateString(identifier) : 0;
  return HMFlatBuffer::CreateHmRefProcessGroupStatesGlobal(
      _fbb,
      identifier__,
      expiredSupervisionTolerance);
}

struct RecoveryNotification FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RecoveryNotificationBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SHORTNAME = 4,
    VT_RECOVERYNOTIFICATIONTIMEOUT = 6,
    VT_PROCESSGROUPMETAMODELIDENTIFIER = 8,
    VT_REFGLOBALSUPERVISIONINDEX = 10,
    VT_INSTANCESPECIFIER = 12,
    VT_SHOULDFIREWATCHDOG = 14
  };
  const ::flatbuffers::String *shortName() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SHORTNAME);
  }
  double recoveryNotificationTimeout() const {
    return GetField<double>(VT_RECOVERYNOTIFICATIONTIMEOUT, 0.0);
  }
  const ::flatbuffers::String *processGroupMetaModelIdentifier() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PROCESSGROUPMETAMODELIDENTIFIER);
  }
  uint32_t refGlobalSupervisionIndex() const {
    return GetField<uint32_t>(VT_REFGLOBALSUPERVISIONINDEX, 0);
  }
  const ::flatbuffers::String *instanceSpecifier() const {
    return GetPointer<const ::flatbuffers::String *>(VT_INSTANCESPECIFIER);
  }
  bool shouldFireWatchdog() const {
    return GetField<uint8_t>(VT_SHOULDFIREWATCHDOG, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SHORTNAME) &&
           verifier.VerifyString(shortName()) &&
           VerifyField<double>(verifier, VT_RECOVERYNOTIFICATIONTIMEOUT, 8) &&
           VerifyOffset(verifier, VT_PROCESSGROUPMETAMODELIDENTIFIER) &&
           verifier.VerifyString(processGroupMetaModelIdentifier()) &&
           VerifyField<uint32_t>(verifier, VT_REFGLOBALSUPERVISIONINDEX, 4) &&
           VerifyOffset(verifier, VT_INSTANCESPECIFIER) &&
           verifier.VerifyString(instanceSpecifier()) &&
           VerifyField<uint8_t>(verifier, VT_SHOULDFIREWATCHDOG, 1) &&
           verifier.EndTable();
  }
};

struct RecoveryNotificationBuilder {
  typedef RecoveryNotification Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_shortName(::flatbuffers::Offset<::flatbuffers::String> shortName) {
    fbb_.AddOffset(RecoveryNotification::VT_SHORTNAME, shortName);
  }
  void add_recoveryNotificationTimeout(double recoveryNotificationTimeout) {
    fbb_.AddElement<double>(RecoveryNotification::VT_RECOVERYNOTIFICATIONTIMEOUT, recoveryNotificationTimeout, 0.0);
  }
  void add_processGroupMetaModelIdentifier(::flatbuffers::Offset<::flatbuffers::String> processGroupMetaModelIdentifier) {
    fbb_.AddOffset(RecoveryNotification::VT_PROCESSGROUPMETAMODELIDENTIFIER, processGroupMetaModelIdentifier);
  }
  void add_refGlobalSupervisionIndex(uint32_t refGlobalSupervisionIndex) {
    fbb_.AddElement<uint32_t>(RecoveryNotification::VT_REFGLOBALSUPERVISIONINDEX, refGlobalSupervisionIndex, 0);
  }
  void add_instanceSpecifier(::flatbuffers::Offset<::flatbuffers::String> instanceSpecifier) {
    fbb_.AddOffset(RecoveryNotification::VT_INSTANCESPECIFIER, instanceSpecifier);
  }
  void add_shouldFireWatchdog(bool shouldFireWatchdog) {
    fbb_.AddElement<uint8_t>(RecoveryNotification::VT_SHOULDFIREWATCHDOG, static_cast<uint8_t>(shouldFireWatchdog), 0);
  }
  explicit RecoveryNotificationBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RecoveryNotification> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RecoveryNotification>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RecoveryNotification> CreateRecoveryNotification(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> shortName = 0,
    double recoveryNotificationTimeout = 0.0,
    ::flatbuffers::Offset<::flatbuffers::String> processGroupMetaModelIdentifier = 0,
    uint32_t refGlobalSupervisionIndex = 0,
    ::flatbuffers::Offset<::flatbuffers::String> instanceSpecifier = 0,
    bool shouldFireWatchdog = false) {
  RecoveryNotificationBuilder builder_(_fbb);
  builder_.add_recoveryNotificationTimeout(recoveryNotificationTimeout);
  builder_.add_instanceSpecifier(instanceSpecifier);
  builder_.add_refGlobalSupervisionIndex(refGlobalSupervisionIndex);
  builder_.add_processGroupMetaModelIdentifier(processGroupMetaModelIdentifier);
  builder_.add_shortName(shortName);
  builder_.add_shouldFireWatchdog(shouldFireWatchdog);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<RecoveryNotification> CreateRecoveryNotificationDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *shortName = nullptr,
    double recoveryNotificationTimeout = 0.0,
    const char *processGroupMetaModelIdentifier = nullptr,
    uint32_t refGlobalSupervisionIndex = 0,
    const char *instanceSpecifier = nullptr,
    bool shouldFireWatchdog = false) {
  auto shortName__ = shortName ? _fbb.CreateString(shortName) : 0;
  auto processGroupMetaModelIdentifier__ = processGroupMetaModelIdentifier ? _fbb.CreateString(processGroupMetaModelIdentifier) : 0;
  auto instanceSpecifier__ = instanceSpecifier ? _fbb.CreateString(instanceSpecifier) : 0;
  return HMFlatBuffer::CreateRecoveryNotification(
      _fbb,
      shortName__,
      recoveryNotificationTimeout,
      processGroupMetaModelIdentifier__,
      refGlobalSupervisionIndex,
      instanceSpecifier__,
      shouldFireWatchdog);
}

inline const HMFlatBuffer::HMEcuCfg *GetHMEcuCfg(const void *buf) {
  return ::flatbuffers::GetRoot<HMFlatBuffer::HMEcuCfg>(buf);
}

inline const HMFlatBuffer::HMEcuCfg *GetSizePrefixedHMEcuCfg(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<HMFlatBuffer::HMEcuCfg>(buf);
}

inline const char *HMEcuCfgIdentifier() {
  return "BHMT";
}

inline bool HMEcuCfgBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, HMEcuCfgIdentifier());
}

inline bool SizePrefixedHMEcuCfgBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, HMEcuCfgIdentifier(), true);
}

inline bool VerifyHMEcuCfgBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<HMFlatBuffer::HMEcuCfg>(HMEcuCfgIdentifier());
}

inline bool VerifySizePrefixedHMEcuCfgBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<HMFlatBuffer::HMEcuCfg>(HMEcuCfgIdentifier());
}

inline const char *HMEcuCfgExtension() {
  return "bin";
}

inline void FinishHMEcuCfgBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<HMFlatBuffer::HMEcuCfg> root) {
  fbb.Finish(root, HMEcuCfgIdentifier());
}

inline void FinishSizePrefixedHMEcuCfgBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<HMFlatBuffer::HMEcuCfg> root) {
  fbb.FinishSizePrefixed(root, HMEcuCfgIdentifier());
}

}  // namespace HMFlatBuffer

#endif  // FLATBUFFERS_GENERATED_HMFLATCFG_HMFLATBUFFER_H_
