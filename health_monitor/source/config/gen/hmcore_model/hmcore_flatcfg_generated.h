/********************************************************************************
 * Copyright (c) 2025 Contributors to the Eclipse Foundation
 *
 * See the NOTICE file(s) distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Apache License Version 2.0 which is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * SPDX-License-Identifier: Apache-2.0
 ********************************************************************************/
// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_HMCOREFLATCFG_HMCOREFLATBUFFER_H_
#define FLATBUFFERS_GENERATED_HMCOREFLATCFG_HMCOREFLATBUFFER_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 25 &&
              FLATBUFFERS_VERSION_MINOR == 9 &&
              FLATBUFFERS_VERSION_REVISION == 23,
             "Non-compatible flatbuffers version included");

namespace HMCOREFlatBuffer {

struct HMCOREEcuCfg;
struct HMCOREEcuCfgBuilder;

struct Watchdog;
struct WatchdogBuilder;

struct HmConfig;
struct HmConfigBuilder;

struct HMCOREEcuCfg FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef HMCOREEcuCfgBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VERSIONMAJOR = 4,
    VT_VERSIONMINOR = 6,
    VT_WATCHDOGS = 8,
    VT_CONFIG = 10
  };
  int32_t versionMajor() const {
    return GetField<int32_t>(VT_VERSIONMAJOR, 0);
  }
  int32_t versionMinor() const {
    return GetField<int32_t>(VT_VERSIONMINOR, 0);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<HMCOREFlatBuffer::Watchdog>> *watchdogs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<HMCOREFlatBuffer::Watchdog>> *>(VT_WATCHDOGS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<HMCOREFlatBuffer::HmConfig>> *config() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<HMCOREFlatBuffer::HmConfig>> *>(VT_CONFIG);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_VERSIONMAJOR, 4) &&
           VerifyField<int32_t>(verifier, VT_VERSIONMINOR, 4) &&
           VerifyOffset(verifier, VT_WATCHDOGS) &&
           verifier.VerifyVector(watchdogs()) &&
           verifier.VerifyVectorOfTables(watchdogs()) &&
           VerifyOffset(verifier, VT_CONFIG) &&
           verifier.VerifyVector(config()) &&
           verifier.VerifyVectorOfTables(config()) &&
           verifier.EndTable();
  }
};

struct HMCOREEcuCfgBuilder {
  typedef HMCOREEcuCfg Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_versionMajor(int32_t versionMajor) {
    fbb_.AddElement<int32_t>(HMCOREEcuCfg::VT_VERSIONMAJOR, versionMajor, 0);
  }
  void add_versionMinor(int32_t versionMinor) {
    fbb_.AddElement<int32_t>(HMCOREEcuCfg::VT_VERSIONMINOR, versionMinor, 0);
  }
  void add_watchdogs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<HMCOREFlatBuffer::Watchdog>>> watchdogs) {
    fbb_.AddOffset(HMCOREEcuCfg::VT_WATCHDOGS, watchdogs);
  }
  void add_config(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<HMCOREFlatBuffer::HmConfig>>> config) {
    fbb_.AddOffset(HMCOREEcuCfg::VT_CONFIG, config);
  }
  explicit HMCOREEcuCfgBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<HMCOREEcuCfg> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<HMCOREEcuCfg>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<HMCOREEcuCfg> CreateHMCOREEcuCfg(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t versionMajor = 0,
    int32_t versionMinor = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<HMCOREFlatBuffer::Watchdog>>> watchdogs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<HMCOREFlatBuffer::HmConfig>>> config = 0) {
  HMCOREEcuCfgBuilder builder_(_fbb);
  builder_.add_config(config);
  builder_.add_watchdogs(watchdogs);
  builder_.add_versionMinor(versionMinor);
  builder_.add_versionMajor(versionMajor);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<HMCOREEcuCfg> CreateHMCOREEcuCfgDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t versionMajor = 0,
    int32_t versionMinor = 0,
    const std::vector<::flatbuffers::Offset<HMCOREFlatBuffer::Watchdog>> *watchdogs = nullptr,
    const std::vector<::flatbuffers::Offset<HMCOREFlatBuffer::HmConfig>> *config = nullptr) {
  auto watchdogs__ = watchdogs ? _fbb.CreateVector<::flatbuffers::Offset<HMCOREFlatBuffer::Watchdog>>(*watchdogs) : 0;
  auto config__ = config ? _fbb.CreateVector<::flatbuffers::Offset<HMCOREFlatBuffer::HmConfig>>(*config) : 0;
  return HMCOREFlatBuffer::CreateHMCOREEcuCfg(
      _fbb,
      versionMajor,
      versionMinor,
      watchdogs__,
      config__);
}

struct Watchdog FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef WatchdogBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SHORTNAME = 4,
    VT_DEVICEFILEPATH = 6,
    VT_MAXTIMEOUT = 8,
    VT_DEACTIVATEONSHUTDOWN = 10,
    VT_HASVALUEDEACTIVATEONSHUTDOWN = 12,
    VT_REQUIREMAGICCLOSE = 14,
    VT_HASVALUEREQUIREMAGICCLOSE = 16
  };
  const ::flatbuffers::String *shortName() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SHORTNAME);
  }
  const ::flatbuffers::String *deviceFilePath() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DEVICEFILEPATH);
  }
  uint32_t maxTimeout() const {
    return GetField<uint32_t>(VT_MAXTIMEOUT, 0);
  }
  bool deactivateOnShutdown() const {
    return GetField<uint8_t>(VT_DEACTIVATEONSHUTDOWN, 0) != 0;
  }
  bool hasValueDeactivateOnShutdown() const {
    return GetField<uint8_t>(VT_HASVALUEDEACTIVATEONSHUTDOWN, 0) != 0;
  }
  bool requireMagicClose() const {
    return GetField<uint8_t>(VT_REQUIREMAGICCLOSE, 0) != 0;
  }
  bool hasValueRequireMagicClose() const {
    return GetField<uint8_t>(VT_HASVALUEREQUIREMAGICCLOSE, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SHORTNAME) &&
           verifier.VerifyString(shortName()) &&
           VerifyOffset(verifier, VT_DEVICEFILEPATH) &&
           verifier.VerifyString(deviceFilePath()) &&
           VerifyField<uint32_t>(verifier, VT_MAXTIMEOUT, 4) &&
           VerifyField<uint8_t>(verifier, VT_DEACTIVATEONSHUTDOWN, 1) &&
           VerifyField<uint8_t>(verifier, VT_HASVALUEDEACTIVATEONSHUTDOWN, 1) &&
           VerifyField<uint8_t>(verifier, VT_REQUIREMAGICCLOSE, 1) &&
           VerifyField<uint8_t>(verifier, VT_HASVALUEREQUIREMAGICCLOSE, 1) &&
           verifier.EndTable();
  }
};

struct WatchdogBuilder {
  typedef Watchdog Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_shortName(::flatbuffers::Offset<::flatbuffers::String> shortName) {
    fbb_.AddOffset(Watchdog::VT_SHORTNAME, shortName);
  }
  void add_deviceFilePath(::flatbuffers::Offset<::flatbuffers::String> deviceFilePath) {
    fbb_.AddOffset(Watchdog::VT_DEVICEFILEPATH, deviceFilePath);
  }
  void add_maxTimeout(uint32_t maxTimeout) {
    fbb_.AddElement<uint32_t>(Watchdog::VT_MAXTIMEOUT, maxTimeout, 0);
  }
  void add_deactivateOnShutdown(bool deactivateOnShutdown) {
    fbb_.AddElement<uint8_t>(Watchdog::VT_DEACTIVATEONSHUTDOWN, static_cast<uint8_t>(deactivateOnShutdown), 0);
  }
  void add_hasValueDeactivateOnShutdown(bool hasValueDeactivateOnShutdown) {
    fbb_.AddElement<uint8_t>(Watchdog::VT_HASVALUEDEACTIVATEONSHUTDOWN, static_cast<uint8_t>(hasValueDeactivateOnShutdown), 0);
  }
  void add_requireMagicClose(bool requireMagicClose) {
    fbb_.AddElement<uint8_t>(Watchdog::VT_REQUIREMAGICCLOSE, static_cast<uint8_t>(requireMagicClose), 0);
  }
  void add_hasValueRequireMagicClose(bool hasValueRequireMagicClose) {
    fbb_.AddElement<uint8_t>(Watchdog::VT_HASVALUEREQUIREMAGICCLOSE, static_cast<uint8_t>(hasValueRequireMagicClose), 0);
  }
  explicit WatchdogBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Watchdog> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Watchdog>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Watchdog> CreateWatchdog(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> shortName = 0,
    ::flatbuffers::Offset<::flatbuffers::String> deviceFilePath = 0,
    uint32_t maxTimeout = 0,
    bool deactivateOnShutdown = false,
    bool hasValueDeactivateOnShutdown = false,
    bool requireMagicClose = false,
    bool hasValueRequireMagicClose = false) {
  WatchdogBuilder builder_(_fbb);
  builder_.add_maxTimeout(maxTimeout);
  builder_.add_deviceFilePath(deviceFilePath);
  builder_.add_shortName(shortName);
  builder_.add_hasValueRequireMagicClose(hasValueRequireMagicClose);
  builder_.add_requireMagicClose(requireMagicClose);
  builder_.add_hasValueDeactivateOnShutdown(hasValueDeactivateOnShutdown);
  builder_.add_deactivateOnShutdown(deactivateOnShutdown);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Watchdog> CreateWatchdogDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *shortName = nullptr,
    const char *deviceFilePath = nullptr,
    uint32_t maxTimeout = 0,
    bool deactivateOnShutdown = false,
    bool hasValueDeactivateOnShutdown = false,
    bool requireMagicClose = false,
    bool hasValueRequireMagicClose = false) {
  auto shortName__ = shortName ? _fbb.CreateString(shortName) : 0;
  auto deviceFilePath__ = deviceFilePath ? _fbb.CreateString(deviceFilePath) : 0;
  return HMCOREFlatBuffer::CreateWatchdog(
      _fbb,
      shortName__,
      deviceFilePath__,
      maxTimeout,
      deactivateOnShutdown,
      hasValueDeactivateOnShutdown,
      requireMagicClose,
      hasValueRequireMagicClose);
}

struct HmConfig FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef HmConfigBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ENABLETERMINATIONREQUEST = 4,
    VT_HASVALUEENABLETERMINATIONREQUEST = 6,
    VT_PERIODICITY = 8,
    VT_BUFFERSIZEMONITOR = 10,
    VT_BUFFERSIZEALIVESUPERVISION = 12,
    VT_BUFFERSIZEDEADLINESUPERVISION = 14,
    VT_BUFFERSIZELOGICALSUPERVISION = 16,
    VT_BUFFERSIZELOCALSUPERVISION = 18,
    VT_BUFFERSIZEGLOBALSUPERVISION = 20
  };
  bool enableTerminationRequest() const {
    return GetField<uint8_t>(VT_ENABLETERMINATIONREQUEST, 0) != 0;
  }
  bool hasValueEnableTerminationRequest() const {
    return GetField<uint8_t>(VT_HASVALUEENABLETERMINATIONREQUEST, 0) != 0;
  }
  uint32_t periodicity() const {
    return GetField<uint32_t>(VT_PERIODICITY, 0);
  }
  uint16_t bufferSizeMonitor() const {
    return GetField<uint16_t>(VT_BUFFERSIZEMONITOR, 0);
  }
  uint16_t bufferSizeAliveSupervision() const {
    return GetField<uint16_t>(VT_BUFFERSIZEALIVESUPERVISION, 0);
  }
  uint16_t bufferSizeDeadlineSupervision() const {
    return GetField<uint16_t>(VT_BUFFERSIZEDEADLINESUPERVISION, 0);
  }
  uint16_t bufferSizeLogicalSupervision() const {
    return GetField<uint16_t>(VT_BUFFERSIZELOGICALSUPERVISION, 0);
  }
  uint16_t bufferSizeLocalSupervision() const {
    return GetField<uint16_t>(VT_BUFFERSIZELOCALSUPERVISION, 0);
  }
  uint16_t bufferSizeGlobalSupervision() const {
    return GetField<uint16_t>(VT_BUFFERSIZEGLOBALSUPERVISION, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ENABLETERMINATIONREQUEST, 1) &&
           VerifyField<uint8_t>(verifier, VT_HASVALUEENABLETERMINATIONREQUEST, 1) &&
           VerifyField<uint32_t>(verifier, VT_PERIODICITY, 4) &&
           VerifyField<uint16_t>(verifier, VT_BUFFERSIZEMONITOR, 2) &&
           VerifyField<uint16_t>(verifier, VT_BUFFERSIZEALIVESUPERVISION, 2) &&
           VerifyField<uint16_t>(verifier, VT_BUFFERSIZEDEADLINESUPERVISION, 2) &&
           VerifyField<uint16_t>(verifier, VT_BUFFERSIZELOGICALSUPERVISION, 2) &&
           VerifyField<uint16_t>(verifier, VT_BUFFERSIZELOCALSUPERVISION, 2) &&
           VerifyField<uint16_t>(verifier, VT_BUFFERSIZEGLOBALSUPERVISION, 2) &&
           verifier.EndTable();
  }
};

struct HmConfigBuilder {
  typedef HmConfig Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_enableTerminationRequest(bool enableTerminationRequest) {
    fbb_.AddElement<uint8_t>(HmConfig::VT_ENABLETERMINATIONREQUEST, static_cast<uint8_t>(enableTerminationRequest), 0);
  }
  void add_hasValueEnableTerminationRequest(bool hasValueEnableTerminationRequest) {
    fbb_.AddElement<uint8_t>(HmConfig::VT_HASVALUEENABLETERMINATIONREQUEST, static_cast<uint8_t>(hasValueEnableTerminationRequest), 0);
  }
  void add_periodicity(uint32_t periodicity) {
    fbb_.AddElement<uint32_t>(HmConfig::VT_PERIODICITY, periodicity, 0);
  }
  void add_bufferSizeMonitor(uint16_t bufferSizeMonitor) {
    fbb_.AddElement<uint16_t>(HmConfig::VT_BUFFERSIZEMONITOR, bufferSizeMonitor, 0);
  }
  void add_bufferSizeAliveSupervision(uint16_t bufferSizeAliveSupervision) {
    fbb_.AddElement<uint16_t>(HmConfig::VT_BUFFERSIZEALIVESUPERVISION, bufferSizeAliveSupervision, 0);
  }
  void add_bufferSizeDeadlineSupervision(uint16_t bufferSizeDeadlineSupervision) {
    fbb_.AddElement<uint16_t>(HmConfig::VT_BUFFERSIZEDEADLINESUPERVISION, bufferSizeDeadlineSupervision, 0);
  }
  void add_bufferSizeLogicalSupervision(uint16_t bufferSizeLogicalSupervision) {
    fbb_.AddElement<uint16_t>(HmConfig::VT_BUFFERSIZELOGICALSUPERVISION, bufferSizeLogicalSupervision, 0);
  }
  void add_bufferSizeLocalSupervision(uint16_t bufferSizeLocalSupervision) {
    fbb_.AddElement<uint16_t>(HmConfig::VT_BUFFERSIZELOCALSUPERVISION, bufferSizeLocalSupervision, 0);
  }
  void add_bufferSizeGlobalSupervision(uint16_t bufferSizeGlobalSupervision) {
    fbb_.AddElement<uint16_t>(HmConfig::VT_BUFFERSIZEGLOBALSUPERVISION, bufferSizeGlobalSupervision, 0);
  }
  explicit HmConfigBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<HmConfig> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<HmConfig>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<HmConfig> CreateHmConfig(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool enableTerminationRequest = false,
    bool hasValueEnableTerminationRequest = false,
    uint32_t periodicity = 0,
    uint16_t bufferSizeMonitor = 0,
    uint16_t bufferSizeAliveSupervision = 0,
    uint16_t bufferSizeDeadlineSupervision = 0,
    uint16_t bufferSizeLogicalSupervision = 0,
    uint16_t bufferSizeLocalSupervision = 0,
    uint16_t bufferSizeGlobalSupervision = 0) {
  HmConfigBuilder builder_(_fbb);
  builder_.add_periodicity(periodicity);
  builder_.add_bufferSizeGlobalSupervision(bufferSizeGlobalSupervision);
  builder_.add_bufferSizeLocalSupervision(bufferSizeLocalSupervision);
  builder_.add_bufferSizeLogicalSupervision(bufferSizeLogicalSupervision);
  builder_.add_bufferSizeDeadlineSupervision(bufferSizeDeadlineSupervision);
  builder_.add_bufferSizeAliveSupervision(bufferSizeAliveSupervision);
  builder_.add_bufferSizeMonitor(bufferSizeMonitor);
  builder_.add_hasValueEnableTerminationRequest(hasValueEnableTerminationRequest);
  builder_.add_enableTerminationRequest(enableTerminationRequest);
  return builder_.Finish();
}

inline const HMCOREFlatBuffer::HMCOREEcuCfg *GetHMCOREEcuCfg(const void *buf) {
  return ::flatbuffers::GetRoot<HMCOREFlatBuffer::HMCOREEcuCfg>(buf);
}

inline const HMCOREFlatBuffer::HMCOREEcuCfg *GetSizePrefixedHMCOREEcuCfg(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<HMCOREFlatBuffer::HMCOREEcuCfg>(buf);
}

inline const char *HMCOREEcuCfgIdentifier() {
  return "BHMR";
}

inline bool HMCOREEcuCfgBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, HMCOREEcuCfgIdentifier());
}

inline bool SizePrefixedHMCOREEcuCfgBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, HMCOREEcuCfgIdentifier(), true);
}

inline bool VerifyHMCOREEcuCfgBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<HMCOREFlatBuffer::HMCOREEcuCfg>(HMCOREEcuCfgIdentifier());
}

inline bool VerifySizePrefixedHMCOREEcuCfgBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<HMCOREFlatBuffer::HMCOREEcuCfg>(HMCOREEcuCfgIdentifier());
}

inline const char *HMCOREEcuCfgExtension() {
  return "bin";
}

inline void FinishHMCOREEcuCfgBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<HMCOREFlatBuffer::HMCOREEcuCfg> root) {
  fbb.Finish(root, HMCOREEcuCfgIdentifier());
}

inline void FinishSizePrefixedHMCOREEcuCfgBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<HMCOREFlatBuffer::HMCOREEcuCfg> root) {
  fbb.FinishSizePrefixed(root, HMCOREEcuCfgIdentifier());
}

}  // namespace HMCOREFlatBuffer

#endif  // FLATBUFFERS_GENERATED_HMCOREFLATCFG_HMCOREFLATBUFFER_H_
