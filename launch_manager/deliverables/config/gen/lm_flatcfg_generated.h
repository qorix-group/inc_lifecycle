/********************************************************************************
 * Copyright (c) 2025 Contributors to the Eclipse Foundation
 *
 * See the NOTICE file(s) distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Apache License Version 2.0 which is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * SPDX-License-Identifier: Apache-2.0
 ********************************************************************************/
// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_LMFLATCFG_LMFLATBUFFER_H_
#define FLATBUFFERS_GENERATED_LMFLATCFG_LMFLATBUFFER_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 25 &&
              FLATBUFFERS_VERSION_MINOR == 9 &&
              FLATBUFFERS_VERSION_REVISION == 23,
             "Non-compatible flatbuffers version included");

namespace LMFlatBuffer {

struct LMEcuCfg;
struct LMEcuCfgBuilder;

struct ModeGroup;
struct ModeGroupBuilder;

struct ModeDeclaration;
struct ModeDeclarationBuilder;

struct Process;
struct ProcessBuilder;

struct ProcessStartupConfig;
struct ProcessStartupConfigBuilder;

struct ProcessGroupStateDependency;
struct ProcessGroupStateDependencyBuilder;

struct ProcessExecutionDependency;
struct ProcessExecutionDependencyBuilder;

struct EnvironmentVariable;
struct EnvironmentVariableBuilder;

struct ProcessArgument;
struct ProcessArgumentBuilder;

struct ProcessSgid;
struct ProcessSgidBuilder;

enum ExecutionStateReportingBehaviorEnum : int8_t {
  ExecutionStateReportingBehaviorEnum_ReportsExecutionState = 0,
  ExecutionStateReportingBehaviorEnum_DoesNotReportExecutionState = 1,
  ExecutionStateReportingBehaviorEnum_MIN = ExecutionStateReportingBehaviorEnum_ReportsExecutionState,
  ExecutionStateReportingBehaviorEnum_MAX = ExecutionStateReportingBehaviorEnum_DoesNotReportExecutionState
};

inline const ExecutionStateReportingBehaviorEnum (&EnumValuesExecutionStateReportingBehaviorEnum())[2] {
  static const ExecutionStateReportingBehaviorEnum values[] = {
    ExecutionStateReportingBehaviorEnum_ReportsExecutionState,
    ExecutionStateReportingBehaviorEnum_DoesNotReportExecutionState
  };
  return values;
}

inline const char * const *EnumNamesExecutionStateReportingBehaviorEnum() {
  static const char * const names[3] = {
    "ReportsExecutionState",
    "DoesNotReportExecutionState",
    nullptr
  };
  return names;
}

inline const char *EnumNameExecutionStateReportingBehaviorEnum(ExecutionStateReportingBehaviorEnum e) {
  if (::flatbuffers::IsOutRange(e, ExecutionStateReportingBehaviorEnum_ReportsExecutionState, ExecutionStateReportingBehaviorEnum_DoesNotReportExecutionState)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesExecutionStateReportingBehaviorEnum()[index];
}

enum TerminationBehaviorEnum : int8_t {
  TerminationBehaviorEnum_ProcessIsNotSelfTerminating = 0,
  TerminationBehaviorEnum_ProcessIsSelfTerminating = 1,
  TerminationBehaviorEnum_MIN = TerminationBehaviorEnum_ProcessIsNotSelfTerminating,
  TerminationBehaviorEnum_MAX = TerminationBehaviorEnum_ProcessIsSelfTerminating
};

inline const TerminationBehaviorEnum (&EnumValuesTerminationBehaviorEnum())[2] {
  static const TerminationBehaviorEnum values[] = {
    TerminationBehaviorEnum_ProcessIsNotSelfTerminating,
    TerminationBehaviorEnum_ProcessIsSelfTerminating
  };
  return values;
}

inline const char * const *EnumNamesTerminationBehaviorEnum() {
  static const char * const names[3] = {
    "ProcessIsNotSelfTerminating",
    "ProcessIsSelfTerminating",
    nullptr
  };
  return names;
}

inline const char *EnumNameTerminationBehaviorEnum(TerminationBehaviorEnum e) {
  if (::flatbuffers::IsOutRange(e, TerminationBehaviorEnum_ProcessIsNotSelfTerminating, TerminationBehaviorEnum_ProcessIsSelfTerminating)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTerminationBehaviorEnum()[index];
}

struct LMEcuCfg FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef LMEcuCfgBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VERSIONMAJOR = 4,
    VT_VERSIONMINOR = 6,
    VT_MODEGROUP = 8,
    VT_PROCESS = 10
  };
  int32_t versionMajor() const {
    return GetField<int32_t>(VT_VERSIONMAJOR, 0);
  }
  int32_t versionMinor() const {
    return GetField<int32_t>(VT_VERSIONMINOR, 0);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<LMFlatBuffer::ModeGroup>> *ModeGroup() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<LMFlatBuffer::ModeGroup>> *>(VT_MODEGROUP);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<LMFlatBuffer::Process>> *Process() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<LMFlatBuffer::Process>> *>(VT_PROCESS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_VERSIONMAJOR, 4) &&
           VerifyField<int32_t>(verifier, VT_VERSIONMINOR, 4) &&
           VerifyOffset(verifier, VT_MODEGROUP) &&
           verifier.VerifyVector(ModeGroup()) &&
           verifier.VerifyVectorOfTables(ModeGroup()) &&
           VerifyOffset(verifier, VT_PROCESS) &&
           verifier.VerifyVector(Process()) &&
           verifier.VerifyVectorOfTables(Process()) &&
           verifier.EndTable();
  }
};

struct LMEcuCfgBuilder {
  typedef LMEcuCfg Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_versionMajor(int32_t versionMajor) {
    fbb_.AddElement<int32_t>(LMEcuCfg::VT_VERSIONMAJOR, versionMajor, 0);
  }
  void add_versionMinor(int32_t versionMinor) {
    fbb_.AddElement<int32_t>(LMEcuCfg::VT_VERSIONMINOR, versionMinor, 0);
  }
  void add_ModeGroup(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<LMFlatBuffer::ModeGroup>>> ModeGroup) {
    fbb_.AddOffset(LMEcuCfg::VT_MODEGROUP, ModeGroup);
  }
  void add_Process(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<LMFlatBuffer::Process>>> Process) {
    fbb_.AddOffset(LMEcuCfg::VT_PROCESS, Process);
  }
  explicit LMEcuCfgBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<LMEcuCfg> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<LMEcuCfg>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<LMEcuCfg> CreateLMEcuCfg(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t versionMajor = 0,
    int32_t versionMinor = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<LMFlatBuffer::ModeGroup>>> ModeGroup = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<LMFlatBuffer::Process>>> Process = 0) {
  LMEcuCfgBuilder builder_(_fbb);
  builder_.add_Process(Process);
  builder_.add_ModeGroup(ModeGroup);
  builder_.add_versionMinor(versionMinor);
  builder_.add_versionMajor(versionMajor);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<LMEcuCfg> CreateLMEcuCfgDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t versionMajor = 0,
    int32_t versionMinor = 0,
    const std::vector<::flatbuffers::Offset<LMFlatBuffer::ModeGroup>> *ModeGroup = nullptr,
    const std::vector<::flatbuffers::Offset<LMFlatBuffer::Process>> *Process = nullptr) {
  auto ModeGroup__ = ModeGroup ? _fbb.CreateVector<::flatbuffers::Offset<LMFlatBuffer::ModeGroup>>(*ModeGroup) : 0;
  auto Process__ = Process ? _fbb.CreateVector<::flatbuffers::Offset<LMFlatBuffer::Process>>(*Process) : 0;
  return LMFlatBuffer::CreateLMEcuCfg(
      _fbb,
      versionMajor,
      versionMinor,
      ModeGroup__,
      Process__);
}

struct ModeGroup FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ModeGroupBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_IDENTIFIER = 4,
    VT_INITIALMODE_NAME = 6,
    VT_INITIALMODE_VALUE = 8,
    VT_RECOVERYMODE_NAME = 10,
    VT_MODEDECLARATION = 12
  };
  const ::flatbuffers::String *identifier() const {
    return GetPointer<const ::flatbuffers::String *>(VT_IDENTIFIER);
  }
  const ::flatbuffers::String *initialMode_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_INITIALMODE_NAME);
  }
  const ::flatbuffers::String *initialMode_value() const {
    return GetPointer<const ::flatbuffers::String *>(VT_INITIALMODE_VALUE);
  }
  const ::flatbuffers::String *recoveryMode_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_RECOVERYMODE_NAME);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<LMFlatBuffer::ModeDeclaration>> *modeDeclaration() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<LMFlatBuffer::ModeDeclaration>> *>(VT_MODEDECLARATION);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_IDENTIFIER) &&
           verifier.VerifyString(identifier()) &&
           VerifyOffset(verifier, VT_INITIALMODE_NAME) &&
           verifier.VerifyString(initialMode_name()) &&
           VerifyOffset(verifier, VT_INITIALMODE_VALUE) &&
           verifier.VerifyString(initialMode_value()) &&
           VerifyOffset(verifier, VT_RECOVERYMODE_NAME) &&
           verifier.VerifyString(recoveryMode_name()) &&
           VerifyOffset(verifier, VT_MODEDECLARATION) &&
           verifier.VerifyVector(modeDeclaration()) &&
           verifier.VerifyVectorOfTables(modeDeclaration()) &&
           verifier.EndTable();
  }
};

struct ModeGroupBuilder {
  typedef ModeGroup Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_identifier(::flatbuffers::Offset<::flatbuffers::String> identifier) {
    fbb_.AddOffset(ModeGroup::VT_IDENTIFIER, identifier);
  }
  void add_initialMode_name(::flatbuffers::Offset<::flatbuffers::String> initialMode_name) {
    fbb_.AddOffset(ModeGroup::VT_INITIALMODE_NAME, initialMode_name);
  }
  void add_initialMode_value(::flatbuffers::Offset<::flatbuffers::String> initialMode_value) {
    fbb_.AddOffset(ModeGroup::VT_INITIALMODE_VALUE, initialMode_value);
  }
  void add_recoveryMode_name(::flatbuffers::Offset<::flatbuffers::String> recoveryMode_name) {
    fbb_.AddOffset(ModeGroup::VT_RECOVERYMODE_NAME, recoveryMode_name);
  }
  void add_modeDeclaration(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<LMFlatBuffer::ModeDeclaration>>> modeDeclaration) {
    fbb_.AddOffset(ModeGroup::VT_MODEDECLARATION, modeDeclaration);
  }
  explicit ModeGroupBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ModeGroup> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ModeGroup>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ModeGroup> CreateModeGroup(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> identifier = 0,
    ::flatbuffers::Offset<::flatbuffers::String> initialMode_name = 0,
    ::flatbuffers::Offset<::flatbuffers::String> initialMode_value = 0,
    ::flatbuffers::Offset<::flatbuffers::String> recoveryMode_name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<LMFlatBuffer::ModeDeclaration>>> modeDeclaration = 0) {
  ModeGroupBuilder builder_(_fbb);
  builder_.add_modeDeclaration(modeDeclaration);
  builder_.add_recoveryMode_name(recoveryMode_name);
  builder_.add_initialMode_value(initialMode_value);
  builder_.add_initialMode_name(initialMode_name);
  builder_.add_identifier(identifier);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ModeGroup> CreateModeGroupDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *identifier = nullptr,
    const char *initialMode_name = nullptr,
    const char *initialMode_value = nullptr,
    const char *recoveryMode_name = nullptr,
    const std::vector<::flatbuffers::Offset<LMFlatBuffer::ModeDeclaration>> *modeDeclaration = nullptr) {
  auto identifier__ = identifier ? _fbb.CreateString(identifier) : 0;
  auto initialMode_name__ = initialMode_name ? _fbb.CreateString(initialMode_name) : 0;
  auto initialMode_value__ = initialMode_value ? _fbb.CreateString(initialMode_value) : 0;
  auto recoveryMode_name__ = recoveryMode_name ? _fbb.CreateString(recoveryMode_name) : 0;
  auto modeDeclaration__ = modeDeclaration ? _fbb.CreateVector<::flatbuffers::Offset<LMFlatBuffer::ModeDeclaration>>(*modeDeclaration) : 0;
  return LMFlatBuffer::CreateModeGroup(
      _fbb,
      identifier__,
      initialMode_name__,
      initialMode_value__,
      recoveryMode_name__,
      modeDeclaration__);
}

struct ModeDeclaration FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ModeDeclarationBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_IDENTIFIER = 4
  };
  const ::flatbuffers::String *identifier() const {
    return GetPointer<const ::flatbuffers::String *>(VT_IDENTIFIER);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_IDENTIFIER) &&
           verifier.VerifyString(identifier()) &&
           verifier.EndTable();
  }
};

struct ModeDeclarationBuilder {
  typedef ModeDeclaration Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_identifier(::flatbuffers::Offset<::flatbuffers::String> identifier) {
    fbb_.AddOffset(ModeDeclaration::VT_IDENTIFIER, identifier);
  }
  explicit ModeDeclarationBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ModeDeclaration> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ModeDeclaration>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ModeDeclaration> CreateModeDeclaration(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> identifier = 0) {
  ModeDeclarationBuilder builder_(_fbb);
  builder_.add_identifier(identifier);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ModeDeclaration> CreateModeDeclarationDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *identifier = nullptr) {
  auto identifier__ = identifier ? _fbb.CreateString(identifier) : 0;
  return LMFlatBuffer::CreateModeDeclaration(
      _fbb,
      identifier__);
}

struct Process FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ProcessBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_IDENTIFIER = 4,
    VT_NUMBEROFRESTARTATTEMPTS = 6,
    VT_FUNCTIONCLUSTERAFFILIATION = 8,
    VT_COREMASK = 10,
    VT_UID = 12,
    VT_GID = 14,
    VT_PATH = 16,
    VT_SECURITYPOLICYDETAILS = 18,
    VT_EXECUTABLE_REPORTINGBEHAVIOR = 20,
    VT_STARTUPCONFIG = 22,
    VT_SGIDS = 24
  };
  const ::flatbuffers::String *identifier() const {
    return GetPointer<const ::flatbuffers::String *>(VT_IDENTIFIER);
  }
  uint32_t numberOfRestartAttempts() const {
    return GetField<uint32_t>(VT_NUMBEROFRESTARTATTEMPTS, 0);
  }
  const ::flatbuffers::String *functionClusterAffiliation() const {
    return GetPointer<const ::flatbuffers::String *>(VT_FUNCTIONCLUSTERAFFILIATION);
  }
  const ::flatbuffers::String *coremask() const {
    return GetPointer<const ::flatbuffers::String *>(VT_COREMASK);
  }
  uint32_t uid() const {
    return GetField<uint32_t>(VT_UID, 0);
  }
  uint32_t gid() const {
    return GetField<uint32_t>(VT_GID, 0);
  }
  const ::flatbuffers::String *path() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PATH);
  }
  const ::flatbuffers::String *securityPolicyDetails() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SECURITYPOLICYDETAILS);
  }
  LMFlatBuffer::ExecutionStateReportingBehaviorEnum executable_reportingBehavior() const {
    return static_cast<LMFlatBuffer::ExecutionStateReportingBehaviorEnum>(GetField<int8_t>(VT_EXECUTABLE_REPORTINGBEHAVIOR, 0));
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<LMFlatBuffer::ProcessStartupConfig>> *startupConfig() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<LMFlatBuffer::ProcessStartupConfig>> *>(VT_STARTUPCONFIG);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<LMFlatBuffer::ProcessSgid>> *sgids() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<LMFlatBuffer::ProcessSgid>> *>(VT_SGIDS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_IDENTIFIER) &&
           verifier.VerifyString(identifier()) &&
           VerifyField<uint32_t>(verifier, VT_NUMBEROFRESTARTATTEMPTS, 4) &&
           VerifyOffset(verifier, VT_FUNCTIONCLUSTERAFFILIATION) &&
           verifier.VerifyString(functionClusterAffiliation()) &&
           VerifyOffset(verifier, VT_COREMASK) &&
           verifier.VerifyString(coremask()) &&
           VerifyField<uint32_t>(verifier, VT_UID, 4) &&
           VerifyField<uint32_t>(verifier, VT_GID, 4) &&
           VerifyOffset(verifier, VT_PATH) &&
           verifier.VerifyString(path()) &&
           VerifyOffset(verifier, VT_SECURITYPOLICYDETAILS) &&
           verifier.VerifyString(securityPolicyDetails()) &&
           VerifyField<int8_t>(verifier, VT_EXECUTABLE_REPORTINGBEHAVIOR, 1) &&
           VerifyOffset(verifier, VT_STARTUPCONFIG) &&
           verifier.VerifyVector(startupConfig()) &&
           verifier.VerifyVectorOfTables(startupConfig()) &&
           VerifyOffset(verifier, VT_SGIDS) &&
           verifier.VerifyVector(sgids()) &&
           verifier.VerifyVectorOfTables(sgids()) &&
           verifier.EndTable();
  }
};

struct ProcessBuilder {
  typedef Process Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_identifier(::flatbuffers::Offset<::flatbuffers::String> identifier) {
    fbb_.AddOffset(Process::VT_IDENTIFIER, identifier);
  }
  void add_numberOfRestartAttempts(uint32_t numberOfRestartAttempts) {
    fbb_.AddElement<uint32_t>(Process::VT_NUMBEROFRESTARTATTEMPTS, numberOfRestartAttempts, 0);
  }
  void add_functionClusterAffiliation(::flatbuffers::Offset<::flatbuffers::String> functionClusterAffiliation) {
    fbb_.AddOffset(Process::VT_FUNCTIONCLUSTERAFFILIATION, functionClusterAffiliation);
  }
  void add_coremask(::flatbuffers::Offset<::flatbuffers::String> coremask) {
    fbb_.AddOffset(Process::VT_COREMASK, coremask);
  }
  void add_uid(uint32_t uid) {
    fbb_.AddElement<uint32_t>(Process::VT_UID, uid, 0);
  }
  void add_gid(uint32_t gid) {
    fbb_.AddElement<uint32_t>(Process::VT_GID, gid, 0);
  }
  void add_path(::flatbuffers::Offset<::flatbuffers::String> path) {
    fbb_.AddOffset(Process::VT_PATH, path);
  }
  void add_securityPolicyDetails(::flatbuffers::Offset<::flatbuffers::String> securityPolicyDetails) {
    fbb_.AddOffset(Process::VT_SECURITYPOLICYDETAILS, securityPolicyDetails);
  }
  void add_executable_reportingBehavior(LMFlatBuffer::ExecutionStateReportingBehaviorEnum executable_reportingBehavior) {
    fbb_.AddElement<int8_t>(Process::VT_EXECUTABLE_REPORTINGBEHAVIOR, static_cast<int8_t>(executable_reportingBehavior), 0);
  }
  void add_startupConfig(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<LMFlatBuffer::ProcessStartupConfig>>> startupConfig) {
    fbb_.AddOffset(Process::VT_STARTUPCONFIG, startupConfig);
  }
  void add_sgids(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<LMFlatBuffer::ProcessSgid>>> sgids) {
    fbb_.AddOffset(Process::VT_SGIDS, sgids);
  }
  explicit ProcessBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Process> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Process>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Process> CreateProcess(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> identifier = 0,
    uint32_t numberOfRestartAttempts = 0,
    ::flatbuffers::Offset<::flatbuffers::String> functionClusterAffiliation = 0,
    ::flatbuffers::Offset<::flatbuffers::String> coremask = 0,
    uint32_t uid = 0,
    uint32_t gid = 0,
    ::flatbuffers::Offset<::flatbuffers::String> path = 0,
    ::flatbuffers::Offset<::flatbuffers::String> securityPolicyDetails = 0,
    LMFlatBuffer::ExecutionStateReportingBehaviorEnum executable_reportingBehavior = LMFlatBuffer::ExecutionStateReportingBehaviorEnum_ReportsExecutionState,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<LMFlatBuffer::ProcessStartupConfig>>> startupConfig = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<LMFlatBuffer::ProcessSgid>>> sgids = 0) {
  ProcessBuilder builder_(_fbb);
  builder_.add_sgids(sgids);
  builder_.add_startupConfig(startupConfig);
  builder_.add_securityPolicyDetails(securityPolicyDetails);
  builder_.add_path(path);
  builder_.add_gid(gid);
  builder_.add_uid(uid);
  builder_.add_coremask(coremask);
  builder_.add_functionClusterAffiliation(functionClusterAffiliation);
  builder_.add_numberOfRestartAttempts(numberOfRestartAttempts);
  builder_.add_identifier(identifier);
  builder_.add_executable_reportingBehavior(executable_reportingBehavior);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Process> CreateProcessDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *identifier = nullptr,
    uint32_t numberOfRestartAttempts = 0,
    const char *functionClusterAffiliation = nullptr,
    const char *coremask = nullptr,
    uint32_t uid = 0,
    uint32_t gid = 0,
    const char *path = nullptr,
    const char *securityPolicyDetails = nullptr,
    LMFlatBuffer::ExecutionStateReportingBehaviorEnum executable_reportingBehavior = LMFlatBuffer::ExecutionStateReportingBehaviorEnum_ReportsExecutionState,
    const std::vector<::flatbuffers::Offset<LMFlatBuffer::ProcessStartupConfig>> *startupConfig = nullptr,
    const std::vector<::flatbuffers::Offset<LMFlatBuffer::ProcessSgid>> *sgids = nullptr) {
  auto identifier__ = identifier ? _fbb.CreateString(identifier) : 0;
  auto functionClusterAffiliation__ = functionClusterAffiliation ? _fbb.CreateString(functionClusterAffiliation) : 0;
  auto coremask__ = coremask ? _fbb.CreateString(coremask) : 0;
  auto path__ = path ? _fbb.CreateString(path) : 0;
  auto securityPolicyDetails__ = securityPolicyDetails ? _fbb.CreateString(securityPolicyDetails) : 0;
  auto startupConfig__ = startupConfig ? _fbb.CreateVector<::flatbuffers::Offset<LMFlatBuffer::ProcessStartupConfig>>(*startupConfig) : 0;
  auto sgids__ = sgids ? _fbb.CreateVector<::flatbuffers::Offset<LMFlatBuffer::ProcessSgid>>(*sgids) : 0;
  return LMFlatBuffer::CreateProcess(
      _fbb,
      identifier__,
      numberOfRestartAttempts,
      functionClusterAffiliation__,
      coremask__,
      uid,
      gid,
      path__,
      securityPolicyDetails__,
      executable_reportingBehavior,
      startupConfig__,
      sgids__);
}

struct ProcessStartupConfig FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ProcessStartupConfigBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_IDENTIFIER = 4,
    VT_ENTERTIMEOUTVALUE = 6,
    VT_EXITTIMEOUTVALUE = 8,
    VT_SCHEDULINGPRIORITY = 10,
    VT_SCHEDULINGPOLICY = 12,
    VT_EXECUTIONERROR = 14,
    VT_TERMINATIONBEHAVIOR = 16,
    VT_EXECUTIONDEPENDENCY = 18,
    VT_PROCESSGROUPSTATEDEPENDENCY = 20,
    VT_ENVIRONMENTVARIABLE = 22,
    VT_PROCESSARGUMENT = 24,
    VT_MEMORYUSAGE = 26
  };
  const ::flatbuffers::String *identifier() const {
    return GetPointer<const ::flatbuffers::String *>(VT_IDENTIFIER);
  }
  uint32_t enterTimeoutValue() const {
    return GetField<uint32_t>(VT_ENTERTIMEOUTVALUE, 0);
  }
  uint32_t exitTimeoutValue() const {
    return GetField<uint32_t>(VT_EXITTIMEOUTVALUE, 0);
  }
  const ::flatbuffers::String *schedulingPriority() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SCHEDULINGPRIORITY);
  }
  const ::flatbuffers::String *schedulingPolicy() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SCHEDULINGPOLICY);
  }
  const ::flatbuffers::String *executionError() const {
    return GetPointer<const ::flatbuffers::String *>(VT_EXECUTIONERROR);
  }
  LMFlatBuffer::TerminationBehaviorEnum terminationBehavior() const {
    return static_cast<LMFlatBuffer::TerminationBehaviorEnum>(GetField<int8_t>(VT_TERMINATIONBEHAVIOR, 0));
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<LMFlatBuffer::ProcessExecutionDependency>> *executionDependency() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<LMFlatBuffer::ProcessExecutionDependency>> *>(VT_EXECUTIONDEPENDENCY);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<LMFlatBuffer::ProcessGroupStateDependency>> *processGroupStateDependency() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<LMFlatBuffer::ProcessGroupStateDependency>> *>(VT_PROCESSGROUPSTATEDEPENDENCY);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<LMFlatBuffer::EnvironmentVariable>> *environmentVariable() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<LMFlatBuffer::EnvironmentVariable>> *>(VT_ENVIRONMENTVARIABLE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<LMFlatBuffer::ProcessArgument>> *processArgument() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<LMFlatBuffer::ProcessArgument>> *>(VT_PROCESSARGUMENT);
  }
  uint64_t memoryUsage() const {
    return GetField<uint64_t>(VT_MEMORYUSAGE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_IDENTIFIER) &&
           verifier.VerifyString(identifier()) &&
           VerifyField<uint32_t>(verifier, VT_ENTERTIMEOUTVALUE, 4) &&
           VerifyField<uint32_t>(verifier, VT_EXITTIMEOUTVALUE, 4) &&
           VerifyOffset(verifier, VT_SCHEDULINGPRIORITY) &&
           verifier.VerifyString(schedulingPriority()) &&
           VerifyOffset(verifier, VT_SCHEDULINGPOLICY) &&
           verifier.VerifyString(schedulingPolicy()) &&
           VerifyOffset(verifier, VT_EXECUTIONERROR) &&
           verifier.VerifyString(executionError()) &&
           VerifyField<int8_t>(verifier, VT_TERMINATIONBEHAVIOR, 1) &&
           VerifyOffset(verifier, VT_EXECUTIONDEPENDENCY) &&
           verifier.VerifyVector(executionDependency()) &&
           verifier.VerifyVectorOfTables(executionDependency()) &&
           VerifyOffset(verifier, VT_PROCESSGROUPSTATEDEPENDENCY) &&
           verifier.VerifyVector(processGroupStateDependency()) &&
           verifier.VerifyVectorOfTables(processGroupStateDependency()) &&
           VerifyOffset(verifier, VT_ENVIRONMENTVARIABLE) &&
           verifier.VerifyVector(environmentVariable()) &&
           verifier.VerifyVectorOfTables(environmentVariable()) &&
           VerifyOffset(verifier, VT_PROCESSARGUMENT) &&
           verifier.VerifyVector(processArgument()) &&
           verifier.VerifyVectorOfTables(processArgument()) &&
           VerifyField<uint64_t>(verifier, VT_MEMORYUSAGE, 8) &&
           verifier.EndTable();
  }
};

struct ProcessStartupConfigBuilder {
  typedef ProcessStartupConfig Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_identifier(::flatbuffers::Offset<::flatbuffers::String> identifier) {
    fbb_.AddOffset(ProcessStartupConfig::VT_IDENTIFIER, identifier);
  }
  void add_enterTimeoutValue(uint32_t enterTimeoutValue) {
    fbb_.AddElement<uint32_t>(ProcessStartupConfig::VT_ENTERTIMEOUTVALUE, enterTimeoutValue, 0);
  }
  void add_exitTimeoutValue(uint32_t exitTimeoutValue) {
    fbb_.AddElement<uint32_t>(ProcessStartupConfig::VT_EXITTIMEOUTVALUE, exitTimeoutValue, 0);
  }
  void add_schedulingPriority(::flatbuffers::Offset<::flatbuffers::String> schedulingPriority) {
    fbb_.AddOffset(ProcessStartupConfig::VT_SCHEDULINGPRIORITY, schedulingPriority);
  }
  void add_schedulingPolicy(::flatbuffers::Offset<::flatbuffers::String> schedulingPolicy) {
    fbb_.AddOffset(ProcessStartupConfig::VT_SCHEDULINGPOLICY, schedulingPolicy);
  }
  void add_executionError(::flatbuffers::Offset<::flatbuffers::String> executionError) {
    fbb_.AddOffset(ProcessStartupConfig::VT_EXECUTIONERROR, executionError);
  }
  void add_terminationBehavior(LMFlatBuffer::TerminationBehaviorEnum terminationBehavior) {
    fbb_.AddElement<int8_t>(ProcessStartupConfig::VT_TERMINATIONBEHAVIOR, static_cast<int8_t>(terminationBehavior), 0);
  }
  void add_executionDependency(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<LMFlatBuffer::ProcessExecutionDependency>>> executionDependency) {
    fbb_.AddOffset(ProcessStartupConfig::VT_EXECUTIONDEPENDENCY, executionDependency);
  }
  void add_processGroupStateDependency(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<LMFlatBuffer::ProcessGroupStateDependency>>> processGroupStateDependency) {
    fbb_.AddOffset(ProcessStartupConfig::VT_PROCESSGROUPSTATEDEPENDENCY, processGroupStateDependency);
  }
  void add_environmentVariable(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<LMFlatBuffer::EnvironmentVariable>>> environmentVariable) {
    fbb_.AddOffset(ProcessStartupConfig::VT_ENVIRONMENTVARIABLE, environmentVariable);
  }
  void add_processArgument(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<LMFlatBuffer::ProcessArgument>>> processArgument) {
    fbb_.AddOffset(ProcessStartupConfig::VT_PROCESSARGUMENT, processArgument);
  }
  void add_memoryUsage(uint64_t memoryUsage) {
    fbb_.AddElement<uint64_t>(ProcessStartupConfig::VT_MEMORYUSAGE, memoryUsage, 0);
  }
  explicit ProcessStartupConfigBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ProcessStartupConfig> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ProcessStartupConfig>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ProcessStartupConfig> CreateProcessStartupConfig(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> identifier = 0,
    uint32_t enterTimeoutValue = 0,
    uint32_t exitTimeoutValue = 0,
    ::flatbuffers::Offset<::flatbuffers::String> schedulingPriority = 0,
    ::flatbuffers::Offset<::flatbuffers::String> schedulingPolicy = 0,
    ::flatbuffers::Offset<::flatbuffers::String> executionError = 0,
    LMFlatBuffer::TerminationBehaviorEnum terminationBehavior = LMFlatBuffer::TerminationBehaviorEnum_ProcessIsNotSelfTerminating,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<LMFlatBuffer::ProcessExecutionDependency>>> executionDependency = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<LMFlatBuffer::ProcessGroupStateDependency>>> processGroupStateDependency = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<LMFlatBuffer::EnvironmentVariable>>> environmentVariable = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<LMFlatBuffer::ProcessArgument>>> processArgument = 0,
    uint64_t memoryUsage = 0) {
  ProcessStartupConfigBuilder builder_(_fbb);
  builder_.add_memoryUsage(memoryUsage);
  builder_.add_processArgument(processArgument);
  builder_.add_environmentVariable(environmentVariable);
  builder_.add_processGroupStateDependency(processGroupStateDependency);
  builder_.add_executionDependency(executionDependency);
  builder_.add_executionError(executionError);
  builder_.add_schedulingPolicy(schedulingPolicy);
  builder_.add_schedulingPriority(schedulingPriority);
  builder_.add_exitTimeoutValue(exitTimeoutValue);
  builder_.add_enterTimeoutValue(enterTimeoutValue);
  builder_.add_identifier(identifier);
  builder_.add_terminationBehavior(terminationBehavior);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ProcessStartupConfig> CreateProcessStartupConfigDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *identifier = nullptr,
    uint32_t enterTimeoutValue = 0,
    uint32_t exitTimeoutValue = 0,
    const char *schedulingPriority = nullptr,
    const char *schedulingPolicy = nullptr,
    const char *executionError = nullptr,
    LMFlatBuffer::TerminationBehaviorEnum terminationBehavior = LMFlatBuffer::TerminationBehaviorEnum_ProcessIsNotSelfTerminating,
    const std::vector<::flatbuffers::Offset<LMFlatBuffer::ProcessExecutionDependency>> *executionDependency = nullptr,
    const std::vector<::flatbuffers::Offset<LMFlatBuffer::ProcessGroupStateDependency>> *processGroupStateDependency = nullptr,
    const std::vector<::flatbuffers::Offset<LMFlatBuffer::EnvironmentVariable>> *environmentVariable = nullptr,
    const std::vector<::flatbuffers::Offset<LMFlatBuffer::ProcessArgument>> *processArgument = nullptr,
    uint64_t memoryUsage = 0) {
  auto identifier__ = identifier ? _fbb.CreateString(identifier) : 0;
  auto schedulingPriority__ = schedulingPriority ? _fbb.CreateString(schedulingPriority) : 0;
  auto schedulingPolicy__ = schedulingPolicy ? _fbb.CreateString(schedulingPolicy) : 0;
  auto executionError__ = executionError ? _fbb.CreateString(executionError) : 0;
  auto executionDependency__ = executionDependency ? _fbb.CreateVector<::flatbuffers::Offset<LMFlatBuffer::ProcessExecutionDependency>>(*executionDependency) : 0;
  auto processGroupStateDependency__ = processGroupStateDependency ? _fbb.CreateVector<::flatbuffers::Offset<LMFlatBuffer::ProcessGroupStateDependency>>(*processGroupStateDependency) : 0;
  auto environmentVariable__ = environmentVariable ? _fbb.CreateVector<::flatbuffers::Offset<LMFlatBuffer::EnvironmentVariable>>(*environmentVariable) : 0;
  auto processArgument__ = processArgument ? _fbb.CreateVector<::flatbuffers::Offset<LMFlatBuffer::ProcessArgument>>(*processArgument) : 0;
  return LMFlatBuffer::CreateProcessStartupConfig(
      _fbb,
      identifier__,
      enterTimeoutValue,
      exitTimeoutValue,
      schedulingPriority__,
      schedulingPolicy__,
      executionError__,
      terminationBehavior,
      executionDependency__,
      processGroupStateDependency__,
      environmentVariable__,
      processArgument__,
      memoryUsage);
}

struct ProcessGroupStateDependency FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ProcessGroupStateDependencyBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STATEMACHINE_NAME = 4,
    VT_STATENAME = 6
  };
  const ::flatbuffers::String *stateMachine_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_STATEMACHINE_NAME);
  }
  const ::flatbuffers::String *stateName() const {
    return GetPointer<const ::flatbuffers::String *>(VT_STATENAME);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_STATEMACHINE_NAME) &&
           verifier.VerifyString(stateMachine_name()) &&
           VerifyOffset(verifier, VT_STATENAME) &&
           verifier.VerifyString(stateName()) &&
           verifier.EndTable();
  }
};

struct ProcessGroupStateDependencyBuilder {
  typedef ProcessGroupStateDependency Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_stateMachine_name(::flatbuffers::Offset<::flatbuffers::String> stateMachine_name) {
    fbb_.AddOffset(ProcessGroupStateDependency::VT_STATEMACHINE_NAME, stateMachine_name);
  }
  void add_stateName(::flatbuffers::Offset<::flatbuffers::String> stateName) {
    fbb_.AddOffset(ProcessGroupStateDependency::VT_STATENAME, stateName);
  }
  explicit ProcessGroupStateDependencyBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ProcessGroupStateDependency> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ProcessGroupStateDependency>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ProcessGroupStateDependency> CreateProcessGroupStateDependency(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> stateMachine_name = 0,
    ::flatbuffers::Offset<::flatbuffers::String> stateName = 0) {
  ProcessGroupStateDependencyBuilder builder_(_fbb);
  builder_.add_stateName(stateName);
  builder_.add_stateMachine_name(stateMachine_name);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ProcessGroupStateDependency> CreateProcessGroupStateDependencyDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *stateMachine_name = nullptr,
    const char *stateName = nullptr) {
  auto stateMachine_name__ = stateMachine_name ? _fbb.CreateString(stateMachine_name) : 0;
  auto stateName__ = stateName ? _fbb.CreateString(stateName) : 0;
  return LMFlatBuffer::CreateProcessGroupStateDependency(
      _fbb,
      stateMachine_name__,
      stateName__);
}

struct ProcessExecutionDependency FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ProcessExecutionDependencyBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STATENAME = 4,
    VT_TARGETPROCESS_IDENTIFIER = 6
  };
  const ::flatbuffers::String *stateName() const {
    return GetPointer<const ::flatbuffers::String *>(VT_STATENAME);
  }
  const ::flatbuffers::String *targetProcess_identifier() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TARGETPROCESS_IDENTIFIER);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_STATENAME) &&
           verifier.VerifyString(stateName()) &&
           VerifyOffset(verifier, VT_TARGETPROCESS_IDENTIFIER) &&
           verifier.VerifyString(targetProcess_identifier()) &&
           verifier.EndTable();
  }
};

struct ProcessExecutionDependencyBuilder {
  typedef ProcessExecutionDependency Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_stateName(::flatbuffers::Offset<::flatbuffers::String> stateName) {
    fbb_.AddOffset(ProcessExecutionDependency::VT_STATENAME, stateName);
  }
  void add_targetProcess_identifier(::flatbuffers::Offset<::flatbuffers::String> targetProcess_identifier) {
    fbb_.AddOffset(ProcessExecutionDependency::VT_TARGETPROCESS_IDENTIFIER, targetProcess_identifier);
  }
  explicit ProcessExecutionDependencyBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ProcessExecutionDependency> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ProcessExecutionDependency>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ProcessExecutionDependency> CreateProcessExecutionDependency(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> stateName = 0,
    ::flatbuffers::Offset<::flatbuffers::String> targetProcess_identifier = 0) {
  ProcessExecutionDependencyBuilder builder_(_fbb);
  builder_.add_targetProcess_identifier(targetProcess_identifier);
  builder_.add_stateName(stateName);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ProcessExecutionDependency> CreateProcessExecutionDependencyDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *stateName = nullptr,
    const char *targetProcess_identifier = nullptr) {
  auto stateName__ = stateName ? _fbb.CreateString(stateName) : 0;
  auto targetProcess_identifier__ = targetProcess_identifier ? _fbb.CreateString(targetProcess_identifier) : 0;
  return LMFlatBuffer::CreateProcessExecutionDependency(
      _fbb,
      stateName__,
      targetProcess_identifier__);
}

struct EnvironmentVariable FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef EnvironmentVariableBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEY = 4,
    VT_VALUE = 6
  };
  const ::flatbuffers::String *key() const {
    return GetPointer<const ::flatbuffers::String *>(VT_KEY);
  }
  const ::flatbuffers::String *value() const {
    return GetPointer<const ::flatbuffers::String *>(VT_VALUE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_KEY) &&
           verifier.VerifyString(key()) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyString(value()) &&
           verifier.EndTable();
  }
};

struct EnvironmentVariableBuilder {
  typedef EnvironmentVariable Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_key(::flatbuffers::Offset<::flatbuffers::String> key) {
    fbb_.AddOffset(EnvironmentVariable::VT_KEY, key);
  }
  void add_value(::flatbuffers::Offset<::flatbuffers::String> value) {
    fbb_.AddOffset(EnvironmentVariable::VT_VALUE, value);
  }
  explicit EnvironmentVariableBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<EnvironmentVariable> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<EnvironmentVariable>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<EnvironmentVariable> CreateEnvironmentVariable(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> key = 0,
    ::flatbuffers::Offset<::flatbuffers::String> value = 0) {
  EnvironmentVariableBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_key(key);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<EnvironmentVariable> CreateEnvironmentVariableDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *key = nullptr,
    const char *value = nullptr) {
  auto key__ = key ? _fbb.CreateString(key) : 0;
  auto value__ = value ? _fbb.CreateString(value) : 0;
  return LMFlatBuffer::CreateEnvironmentVariable(
      _fbb,
      key__,
      value__);
}

struct ProcessArgument FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ProcessArgumentBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ARGUMENT = 4
  };
  const ::flatbuffers::String *argument() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ARGUMENT);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ARGUMENT) &&
           verifier.VerifyString(argument()) &&
           verifier.EndTable();
  }
};

struct ProcessArgumentBuilder {
  typedef ProcessArgument Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_argument(::flatbuffers::Offset<::flatbuffers::String> argument) {
    fbb_.AddOffset(ProcessArgument::VT_ARGUMENT, argument);
  }
  explicit ProcessArgumentBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ProcessArgument> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ProcessArgument>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ProcessArgument> CreateProcessArgument(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> argument = 0) {
  ProcessArgumentBuilder builder_(_fbb);
  builder_.add_argument(argument);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ProcessArgument> CreateProcessArgumentDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *argument = nullptr) {
  auto argument__ = argument ? _fbb.CreateString(argument) : 0;
  return LMFlatBuffer::CreateProcessArgument(
      _fbb,
      argument__);
}

struct ProcessSgid FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ProcessSgidBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SGID = 4
  };
  uint32_t sgid() const {
    return GetField<uint32_t>(VT_SGID, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_SGID, 4) &&
           verifier.EndTable();
  }
};

struct ProcessSgidBuilder {
  typedef ProcessSgid Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_sgid(uint32_t sgid) {
    fbb_.AddElement<uint32_t>(ProcessSgid::VT_SGID, sgid, 0);
  }
  explicit ProcessSgidBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ProcessSgid> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ProcessSgid>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ProcessSgid> CreateProcessSgid(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t sgid = 0) {
  ProcessSgidBuilder builder_(_fbb);
  builder_.add_sgid(sgid);
  return builder_.Finish();
}

inline const LMFlatBuffer::LMEcuCfg *GetLMEcuCfg(const void *buf) {
  return ::flatbuffers::GetRoot<LMFlatBuffer::LMEcuCfg>(buf);
}

inline const LMFlatBuffer::LMEcuCfg *GetSizePrefixedLMEcuCfg(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<LMFlatBuffer::LMEcuCfg>(buf);
}

inline const char *LMEcuCfgIdentifier() {
  return "BLMR";
}

inline bool LMEcuCfgBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, LMEcuCfgIdentifier());
}

inline bool SizePrefixedLMEcuCfgBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, LMEcuCfgIdentifier(), true);
}

inline bool VerifyLMEcuCfgBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<LMFlatBuffer::LMEcuCfg>(LMEcuCfgIdentifier());
}

inline bool VerifySizePrefixedLMEcuCfgBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<LMFlatBuffer::LMEcuCfg>(LMEcuCfgIdentifier());
}

inline const char *LMEcuCfgExtension() {
  return "bin";
}

inline void FinishLMEcuCfgBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<LMFlatBuffer::LMEcuCfg> root) {
  fbb.Finish(root, LMEcuCfgIdentifier());
}

inline void FinishSizePrefixedLMEcuCfgBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<LMFlatBuffer::LMEcuCfg> root) {
  fbb.FinishSizePrefixed(root, LMEcuCfgIdentifier());
}

}  // namespace LMFlatBuffer

#endif  // FLATBUFFERS_GENERATED_LMFLATCFG_LMFLATBUFFER_H_
